// a quick note : the extension is working for compilation 
// of the libs and loading the app into the device via adb
// for the android part but the reason for the tls error 
// on the app side is sill to be solved for proper implementation as 
// the running example for the extension.

#include <gtk/gtk.h>
#include <adwaita.h>
#include <stdio.h>
#ifndef __ANDROID__
#include <gst/gst.h>
#endif
#include <libsoup/soup.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <gmodule.h>

// Declare the GResource function (generated by glib-compile-resources)
#ifdef __ANDROID__
extern "C" GResource *resources_get_resource(void);
#endif

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <iphlpapi.h>
#pragma comment(lib, "iphlpapi.lib")
#endif

// --- Data Structures ---

typedef struct
{
    const char *city;
    int aqi;
    const char *status;
    double pm25;
    double pm10;
    std::vector<int> history; // 24-hour history
} AirQualityData;

// Extended data from WAQI feed
typedef struct
{
    std::string station_id;
    std::string station_name;
    std::string station_url;
    std::string attribution;
    double latitude;
    double longitude;

    // Current values (scaled from raw * 100)
    int aqi;
    double pm25;
    double pm10;
    double o3;
    double no2;
    double co;
    double so2;

    // Weather data
    double temperature;
    double humidity;
    double wind_speed;
    int wind_direction;

    // Hourly history (last 24 hours)
    std::vector<double> pm25_history;
    std::vector<double> pm10_history;
    std::vector<double> o3_history;
    std::vector<double> no2_history;

    bool has_data;
} WAQIStationData;

// Search result item
typedef struct
{
    std::string station_id;
    std::string station_name;
    std::string full_address;
    std::string url;
    std::string country;
    std::string source;
    int aqi;
    bool has_aqi;
} WAQISearchResult;

// Global state
static AirQualityData current_aqi_data;
static WAQIStationData current_station_data;
static std::vector<WAQISearchResult> search_results;
static GtkBuilder *g_current_builder = NULL;
static char *g_api_city_name = NULL;
static guint search_timeout_id = 0;

static int calculate_aqi_from_pm25(double pm)
{
    if (pm <= 0.0)
        return 0;
    if (pm <= 12.0)
        return (int)(pm * 50.0 / 12.0);
    if (pm <= 35.4)
        return (int)(50 + (pm - 12.0) * 50.0 / 23.4);
    if (pm <= 55.4)
        return (int)(100 + (pm - 35.4) * 50.0 / 20.0);
    if (pm <= 150.4)
        return (int)(150 + (pm - 55.4) * 50.0 / 95.0);
    if (pm <= 250.4)
        return (int)(200 + (pm - 150.4) * 100.0 / 100.0);
    if (pm <= 350.4)
        return (int)(300 + (pm - 250.4) * 100.0 / 100.0);
    return (int)(400 + (pm - 350.4) * 100.0 / 150.0);
}

static void set_aqi_status(AirQualityData &data)
{
    int aqi = data.aqi;
    if (aqi < 0)
        aqi = 0;

    if (aqi <= 50)
        data.status = "Good ðŸŸ¢";
    else if (aqi <= 100)
        data.status = "Satisfactory ðŸŸ¡";
    else if (aqi <= 150)
        data.status = "Moderate ðŸŸ ";
    else if (aqi <= 200)
        data.status = "Unhealthy ðŸŸ ";
    else if (aqi <= 300)
        data.status = "Very Unhealthy ðŸ”´";
    else
        data.status = "Hazardous â˜ ï¸";
}

#ifndef __ANDROID__
// SSE streaming state
static SoupSession *sse_session = NULL;
static GCancellable *sse_cancellable = NULL;
static GInputStream *sse_stream = NULL;
static std::string sse_buffer;
static std::string current_sse_station_id;

// WAQI search async state
static SoupSession *search_session = NULL;
static GCancellable *search_cancellable = NULL;
static guint64 search_generation = 0;
#endif

// Mock Data Generator
static AirQualityData get_mock_data(const char *city)
{
    AirQualityData data;
    data.city = city;

    // Simple hash-based randomization for consistent "mock" data per city
    unsigned int hash = 0;
    for (const char *p = city; *p; p++)
        hash = hash * 31 + *p;

    // Use a local seed based on hash for deterministic history
    unsigned int seed = hash;
    auto my_rand = [&seed]()
    {
        seed = seed * 1103515245 + 12345;
        return (unsigned int)(seed / 65536) % 32768;
    };

    data.aqi = (hash % 300) + 50; // Random AQI between 50 and 350

    set_aqi_status(data);

    data.pm25 = (double)(data.aqi) * 0.6;
    data.pm10 = (double)(data.aqi) * 1.2;

    // Generate mock history (24 points)
    data.history.clear();
    int current = data.aqi;
    for (int i = 0; i < 24; i++)
    {
        // Add some random fluctuation
        int fluctuation = (my_rand() % 41) - 20; // -20 to +20
        int val = current + fluctuation;
        if (val < 0)
            val = 0;
        data.history.insert(data.history.begin(), val);
        current = val;
    }

    return data;
}

// --- WAQI Live Search API Functions ---

#ifndef __ANDROID__
// Simple JSON helper to find a value after a key
static const char *json_find_value(const char *json, const char *key)
{
    char search_key[256];
    snprintf(search_key, sizeof(search_key), "\"%s\":", key);
    const char *pos = strstr(json, search_key);
    if (pos)
    {
        pos += strlen(search_key);
        while (*pos == ' ' || *pos == '\t')
            pos++;
        return pos;
    }
    return NULL;
}

// Parse integer from JSON position
static int json_parse_int(const char *pos)
{
    if (!pos)
        return 0;
    if (*pos == '"')
        pos++; // Skip opening quote if string
    return atoi(pos);
}

// Parse double from JSON position
static double json_parse_double(const char *pos)
{
    if (!pos)
        return 0.0;
    if (*pos == '"')
        pos++;
    return atof(pos);
}

// Extract string value from JSON (up to delimiter)
static std::string json_parse_string(const char *pos, size_t max_len = 256)
{
    if (!pos)
        return "";
    std::string result;
    if (*pos == '"')
        pos++;
    while (*pos && *pos != '"' && *pos != ',' && *pos != '}' && result.length() < max_len)
    {
        if (*pos == '\\' && *(pos + 1))
        {
            pos++; // Skip escape
        }
        result += *pos++;
    }
    return result;
}

static void waqi_parse_search_response(const char *data, gsize size, std::vector<WAQISearchResult> &results)
{
    results.clear();
    if (!data || size == 0)
        return;

    const char *results_start = strstr(data, "\"results\":[");
    if (!results_start)
        return;
    results_start += 11; // Skip "results":[

    const char *pos = results_start;
    while (pos && *pos)
    {
        const char *obj_start = strchr(pos, '{');
        if (!obj_start)
            break;

        const char *obj_end = obj_start + 1;
        int brace_count = 1;
        while (*obj_end && brace_count > 0)
        {
            if (*obj_end == '{')
                brace_count++;
            else if (*obj_end == '}')
                brace_count--;
            obj_end++;
        }
        if (brace_count != 0)
            break;

        WAQISearchResult result;

        const char *x_pos = json_find_value(obj_start, "x");
        int x_val = 0;
        if (x_pos)
            x_val = json_parse_int(x_pos);

        const char *s_pos = strstr(obj_start, "\"s\":{");
        if (s_pos && s_pos < obj_end)
        {
            const char *a_pos = strstr(s_pos, "\"a\":\"");
            if (a_pos && a_pos < obj_end)
            {
                a_pos += 5;
                result.aqi = atoi(a_pos);
                result.has_aqi = (result.aqi > 0 || *a_pos == '0');
                if (*a_pos == '-')
                    result.has_aqi = false;
            }

            const char *n_pos = strstr(s_pos, "\"n\":[\"");
            if (n_pos && n_pos < obj_end)
            {
                n_pos += 6;
                result.station_name = json_parse_string(n_pos);
            }

            const char *u_pos = strstr(s_pos, "\"u\":\"");
            if (u_pos && u_pos < obj_end)
            {
                u_pos += 5;
                result.url = json_parse_string(u_pos);

                const char *at_pos = strstr(result.url.c_str(), "@");
                if (at_pos)
                {
                    result.station_id = at_pos + 1;
                }
                else if (x_val != 0)
                {
                    result.station_id = std::to_string(x_val > 0 ? x_val : -x_val);
                }
                else
                {
                    result.station_id = result.url;
                }
            }
            else if (x_val != 0)
            {
                result.station_id = std::to_string(x_val > 0 ? x_val : -x_val);
            }
        }

        if (s_pos)
        {
            const char *after_s = strchr(s_pos + 5, '}');
            if (after_s && after_s < obj_end)
            {
                const char *n_arr = strstr(after_s, "\"n\":[");
                if (n_arr && n_arr < obj_end)
                {
                    const char *p = n_arr + 5;
                    std::string address;
                    int parts = 0;

                    while (p && p < obj_end && *p)
                    {
                        while (p < obj_end && *p && *p != '"' && *p != ']')
                            p++;
                        if (p >= obj_end || !*p || *p == ']')
                            break;
                        if (*p == '"')
                        {
                            std::string part = json_parse_string(p, 512);
                            if (!part.empty())
                            {
                                if (parts++ > 0)
                                    address += " > ";
                                address += part;
                            }
                            p++;
                            while (p < obj_end && *p)
                            {
                                if (*p == '\\' && *(p + 1))
                                {
                                    p += 2;
                                    continue;
                                }
                                if (*p == '"')
                                {
                                    p++;
                                    break;
                                }
                                p++;
                            }
                        }
                    }
                    if (!address.empty())
                        result.full_address = address;
                }
            }
        }

        const char *c_pos = json_find_value(obj_start, "c");
        if (c_pos && c_pos < obj_end)
            result.country = json_parse_string(c_pos);

        const char *src_pos = json_find_value(obj_start, "$");
        if (src_pos && src_pos < obj_end)
            result.source = json_parse_string(src_pos);

        if (!result.station_id.empty() && !result.station_name.empty())
        {
            results.push_back(result);
        }

        pos = obj_end;
    }
}

static void update_aqi_display(GtkBuilder *builder);
static void populate_search_dropdown(GtkBuilder *builder);
static void waqi_fetch_station_data(const std::string &station_id, WAQIStationData &station_data);

static void select_search_result_by_index(GtkBuilder *builder, int idx)
{
    if (!builder)
        return;
    if (idx < 0 || idx >= (int)search_results.size())
        return;

    const WAQISearchResult &result = search_results[idx];
    g_print("Selected station: %s (ID: %s)\n", result.station_name.c_str(), result.station_id.c_str());

    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (entry_obj)
    {
        gtk_editable_set_text(GTK_EDITABLE(entry_obj), result.station_name.c_str());
    }

    GObject *dropdown_obj = gtk_builder_get_object(builder, "search_dropdown");
    if (dropdown_obj)
    {
        gtk_widget_set_visible(GTK_WIDGET(dropdown_obj), FALSE);
    }

    g_current_builder = builder;

    g_free(g_api_city_name);
    g_api_city_name = g_strdup(result.station_name.c_str());
    current_aqi_data.city = g_api_city_name;
    current_aqi_data.aqi = result.has_aqi ? result.aqi : 0;
    current_aqi_data.pm25 = current_aqi_data.aqi * 0.6;
    current_aqi_data.pm10 = current_aqi_data.aqi * 1.2;

    set_aqi_status(current_aqi_data);

    current_aqi_data.history.clear();
    for (int i = 0; i < 24; i++)
    {
        current_aqi_data.history.push_back(current_aqi_data.aqi);
    }

    update_aqi_display(builder);
    waqi_fetch_station_data(result.station_id, current_station_data);
}

typedef enum
{
    SEARCH_MODE_DROPDOWN = 0,
    SEARCH_MODE_AUTO_SELECT_FIRST = 1,
} WAQISearchMode;

typedef struct
{
    GtkBuilder *builder;
    SoupMessage *msg;
    guint64 generation;
    WAQISearchMode mode;
    gchar *query;
} WAQISearchContext;

static void waqi_search_context_free(WAQISearchContext *ctx)
{
    if (!ctx)
        return;
    if (ctx->msg)
        g_object_unref(ctx->msg);
    if (ctx->builder)
        g_object_unref(ctx->builder);
    g_free(ctx->query);
    g_free(ctx);
}

static void on_waqi_search_complete(GObject *source, GAsyncResult *result, gpointer user_data)
{
    WAQISearchContext *ctx = (WAQISearchContext *)user_data;
    GError *error = NULL;
    GBytes *response = soup_session_send_and_read_finish(SOUP_SESSION(source), result, &error);

    if (!ctx || ctx->generation != search_generation)
    {
        if (response)
            g_bytes_unref(response);
        if (error)
            g_clear_error(&error);
        waqi_search_context_free(ctx);
        return;
    }

    if (error)
    {
        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
        {
            g_printerr("WAQI search failed: %s\n", error->message);
        }
        g_clear_error(&error);
        if (response)
            g_bytes_unref(response);

        if (ctx->mode == SEARCH_MODE_AUTO_SELECT_FIRST && ctx->query && *ctx->query)
        {
            current_aqi_data = get_mock_data(ctx->query);
            update_aqi_display(ctx->builder);
        }
        waqi_search_context_free(ctx);
        return;
    }

    gsize size = 0;
    const char *data = (const char *)g_bytes_get_data(response, &size);
    waqi_parse_search_response(data, size, search_results);
    g_bytes_unref(response);

    if (ctx->mode == SEARCH_MODE_AUTO_SELECT_FIRST)
    {
        if (!search_results.empty())
        {
            select_search_result_by_index(ctx->builder, 0);
        }
        else if (ctx->query && *ctx->query)
        {
            current_aqi_data = get_mock_data(ctx->query);
            update_aqi_display(ctx->builder);
        }
    }
    else
    {
        populate_search_dropdown(ctx->builder);
    }

    waqi_search_context_free(ctx);
}

static void waqi_search_cities_async(const char *query, GtkBuilder *builder, WAQISearchMode mode)
{
    if (!builder)
        return;

    if (!query || strlen(query) < 2)
    {
        search_results.clear();
        populate_search_dropdown(builder);
        return;
    }

    if (search_cancellable)
    {
        g_cancellable_cancel(search_cancellable);
        g_clear_object(&search_cancellable);
    }

    if (!search_session)
    {
        search_session = soup_session_new();
    }

    search_generation++;
    search_cancellable = g_cancellable_new();

    char *encoded_query = g_uri_escape_string(query, NULL, TRUE);
    char url[512];
    snprintf(url, sizeof(url), "https://search.waqi.info/nsearch/world/%s?n=10", encoded_query);
    g_free(encoded_query);

    SoupMessage *msg = soup_message_new("GET", url);
    if (!msg)
        return;

    WAQISearchContext *ctx = (WAQISearchContext *)g_malloc0(sizeof(WAQISearchContext));
    ctx->builder = (GtkBuilder *)g_object_ref(builder);
    ctx->msg = (SoupMessage *)g_object_ref(msg);
    ctx->generation = search_generation;
    ctx->mode = mode;
    ctx->query = g_strdup(query);

    soup_session_send_and_read_async(
        search_session,
        msg,
        G_PRIORITY_DEFAULT,
        search_cancellable,
        on_waqi_search_complete,
        ctx);

    g_object_unref(msg);
}

static void sse_read_next_chunk(GInputStream *stream);

static void parse_sse_event(const char *json_data, size_t len)
{
    const char *type_pos = strstr(json_data, "\"type\":\"");
    if (!type_pos)
        return;

    type_pos += 8;

    if (strncmp(type_pos, "meta\"", 5) == 0)
    {
        const char *name_pos = strstr(json_data, "\"name\":\"");
        if (name_pos)
        {
            name_pos += 8;
            current_station_data.station_name = json_parse_string(name_pos);
        }

        const char *geo_pos = strstr(json_data, "\"geo\":[");
        if (geo_pos)
        {
            geo_pos += 7;
            current_station_data.latitude = atof(geo_pos);
            const char *comma = strchr(geo_pos, ',');
            if (comma)
                current_station_data.longitude = atof(comma + 1);
        }

        const char *feed_pos = strstr(json_data, "\"feed\":{");
        if (feed_pos)
        {
            const char *pm25_pos = strstr(feed_pos, "\"pm25\":[");
            if (pm25_pos)
            {
                const char *comma = strchr(pm25_pos + 8, ',');
                if (comma)
                    current_station_data.pm25 = atof(comma + 1) / 100.0;
            }

            const char *pm10_pos = strstr(feed_pos, "\"pm10\":[");
            if (pm10_pos)
            {
                const char *comma = strchr(pm10_pos + 8, ',');
                if (comma)
                    current_station_data.pm10 = atof(comma + 1) / 100.0;
            }

            const char *o3_pos = strstr(feed_pos, "\"o3\":[");
            if (o3_pos)
            {
                const char *comma = strchr(o3_pos + 6, ',');
                if (comma)
                    current_station_data.o3 = atof(comma + 1) / 100.0;
            }

            const char *no2_pos = strstr(feed_pos, "\"no2\":[");
            if (no2_pos)
            {
                const char *comma = strchr(no2_pos + 7, ',');
                if (comma)
                    current_station_data.no2 = atof(comma + 1) / 100.0;
            }

            const char *co_pos = strstr(feed_pos, "\"co\":[");
            if (co_pos)
            {
                const char *comma = strchr(co_pos + 6, ',');
                if (comma)
                    current_station_data.co = atof(comma + 1) / 100.0;
            }

            const char *so2_pos = strstr(feed_pos, "\"so2\":[");
            if (so2_pos)
            {
                const char *comma = strchr(so2_pos + 7, ',');
                if (comma)
                    current_station_data.so2 = atof(comma + 1) / 100.0;
            }
        }

        if (current_station_data.pm25 > 0)
        {
            current_station_data.aqi = calculate_aqi_from_pm25(current_station_data.pm25);
        }

        current_station_data.has_data = true;
    }
    else if (strncmp(type_pos, "instant\"", 8) == 0)
    {

        const char *pm25_pos = strstr(json_data, "\"pm25\":[[");
        if (pm25_pos)
        {
            const char *comma = strchr(pm25_pos + 9, ',');
            if (comma)
            {
                double new_pm25 = atof(comma + 1) / 100.0;
                if (new_pm25 != current_station_data.pm25)
                {
                    current_station_data.pm25 = new_pm25;
                    current_station_data.aqi = calculate_aqi_from_pm25(new_pm25);
                }
            }
        }

        const char *pm10_pos = strstr(json_data, "\"pm10\":[[");
        if (pm10_pos)
        {
            const char *comma = strchr(pm10_pos + 9, ',');
            if (comma)
                current_station_data.pm10 = atof(comma + 1) / 100.0;
        }

        const char *o3_pos = strstr(json_data, "\"o3\":[[");
        if (o3_pos)
        {
            const char *comma = strchr(o3_pos + 7, ',');
            if (comma)
                current_station_data.o3 = atof(comma + 1) / 100.0;
        }

        const char *no2_pos = strstr(json_data, "\"no2\":[[");
        if (no2_pos)
        {
            const char *comma = strchr(no2_pos + 8, ',');
            if (comma)
                current_station_data.no2 = atof(comma + 1) / 100.0;
        }

        const char *co_pos = strstr(json_data, "\"co\":[[");
        if (co_pos)
        {
            const char *comma = strchr(co_pos + 7, ',');
            if (comma)
                current_station_data.co = atof(comma + 1) / 100.0;
        }

        const char *so2_pos = strstr(json_data, "\"so2\":[[");
        if (so2_pos)
        {
            const char *comma = strchr(so2_pos + 8, ',');
            if (comma)
                current_station_data.so2 = atof(comma + 1) / 100.0;
        }
    }
    else if (strncmp(type_pos, "cwop\"", 5) == 0)
    {

        const char *data_pos = strstr(json_data, "\"data\":{");
        if (data_pos)
        {
            const char *last_t = NULL;
            const char *search = data_pos;
            while ((search = strstr(search, "\"t\":")) != NULL)
            {
                if (search > data_pos && *(search - 1) == ',')
                {
                    last_t = search;
                }
                search += 4;
            }

            if (last_t)
            {
                current_station_data.temperature = json_parse_double(last_t + 4);

                const char *entry_start = last_t;
                while (entry_start > data_pos && *entry_start != '{')
                    entry_start--;
                const char *entry_end = strchr(last_t, '}');

                if (entry_end)
                {
                    const char *dew_pos = strstr(entry_start, "\"dew\":");
                    if (dew_pos && dew_pos < entry_end)
                    {
                        double dew = json_parse_double(dew_pos + 6);
                        double t = current_station_data.temperature;
                        double dew_denom = 243.04 + dew;
                        double t_denom = 243.04 + t;
                        if (fabs(dew_denom) > 0.01 && fabs(t_denom) > 0.01)
                        {
                            double alpha_dew = (17.625 * dew) / dew_denom;
                            double alpha_t = (17.625 * t) / t_denom;
                            current_station_data.humidity = 100.0 * exp(alpha_dew - alpha_t);
                            if (current_station_data.humidity > 100)
                                current_station_data.humidity = 100;
                            if (current_station_data.humidity < 0)
                                current_station_data.humidity = 0;
                        }
                    }

                    const char *w_pos = strstr(entry_start, "\"w\":");
                    if (w_pos && w_pos < entry_end)
                    {
                        current_station_data.wind_speed = json_parse_double(w_pos + 4);
                    }

                    const char *wd_pos = strstr(entry_start, "\"wd\":");
                    if (wd_pos && wd_pos < entry_end)
                    {
                        current_station_data.wind_direction = json_parse_int(wd_pos + 5);
                    }
                }
            }
        }
    }
    else if (strncmp(type_pos, "hourly\"", 7) == 0)
    {

        const char *pm25_hourly = strstr(json_data, "\"pm25\":[{");
        if (pm25_hourly)
        {
            current_station_data.pm25_history.clear();
            const char *pos = pm25_hourly + 9;
            int count = 0;
            while (pos && count < 24)
            {
                const char *mean_pos = strstr(pos, "\"mean\":");
                if (!mean_pos)
                    break;
                double val = json_parse_double(mean_pos + 7);
                current_station_data.pm25_history.push_back(val);
                pos = strchr(mean_pos, '}');
                if (pos)
                    pos++;
                count++;
            }
        }

        const char *pm10_hourly = strstr(json_data, "\"pm10\":[{");
        if (pm10_hourly)
        {
            current_station_data.pm10_history.clear();
            const char *pos = pm10_hourly + 9;
            int count = 0;
            while (pos && count < 24)
            {
                const char *mean_pos = strstr(pos, "\"mean\":");
                if (!mean_pos)
                    break;
                double val = json_parse_double(mean_pos + 7);
                current_station_data.pm10_history.push_back(val);
                pos = strchr(mean_pos, '}');
                if (pos)
                    pos++;
                count++;
            }
        }

        const char *o3_hourly = strstr(json_data, "\"o3\":[{");
        if (o3_hourly)
        {
            current_station_data.o3_history.clear();
            const char *pos = o3_hourly + 7;
            int count = 0;
            while (pos && count < 24)
            {
                const char *mean_pos = strstr(pos, "\"mean\":");
                if (!mean_pos)
                    break;
                double val = json_parse_double(mean_pos + 7);
                current_station_data.o3_history.push_back(val);
                pos = strchr(mean_pos, '}');
                if (pos)
                    pos++;
                count++;
            }
        }

        const char *no2_hourly = strstr(json_data, "\"no2\":[{");
        if (no2_hourly)
        {
            current_station_data.no2_history.clear();
            const char *pos = no2_hourly + 8;
            int count = 0;
            while (pos && count < 24)
            {
                const char *mean_pos = strstr(pos, "\"mean\":");
                if (!mean_pos)
                    break;
                double val = json_parse_double(mean_pos + 7);
                current_station_data.no2_history.push_back(val);
                pos = strchr(mean_pos, '}');
                if (pos)
                    pos++;
                count++;
            }
        }
    }

    if (g_current_builder && current_station_data.has_data)
    {
        current_aqi_data.aqi = current_station_data.aqi;
        current_aqi_data.pm25 = current_station_data.pm25;
        current_aqi_data.pm10 = current_station_data.pm10;

        set_aqi_status(current_aqi_data);

        if (!current_station_data.pm25_history.empty())
        {
            current_aqi_data.history.clear();
            for (double val : current_station_data.pm25_history)
            {
                current_aqi_data.history.push_back((int)val);
            }
        }
        while (current_aqi_data.history.size() < 24)
        {
            current_aqi_data.history.insert(current_aqi_data.history.begin(), current_aqi_data.aqi);
        }

        update_aqi_display(g_current_builder);
    }
}

static void process_sse_buffer()
{
    size_t pos = 0;
    while (pos < sse_buffer.size())
    {
        size_t end = sse_buffer.find("\n\n", pos);
        if (end == std::string::npos)
            break;

        std::string message = sse_buffer.substr(pos, end - pos);
        pos = end + 2;

        size_t data_pos = message.find("data: ");
        if (data_pos != std::string::npos)
        {
            std::string json_data = message.substr(data_pos + 6);
            while (!json_data.empty() && (json_data.back() == '\n' || json_data.back() == '\r'))
            {
                json_data.pop_back();
            }

            if (!json_data.empty())
            {
                parse_sse_event(json_data.c_str(), json_data.size());
            }
        }
    }

    if (pos > 0)
    {
        sse_buffer = sse_buffer.substr(pos);
    }
}

static void on_sse_read_complete(GObject *source, GAsyncResult *result, gpointer user_data)
{
    GInputStream *stream = G_INPUT_STREAM(source);
    GError *error = NULL;

    gssize bytes_read = g_input_stream_read_finish(stream, result, &error);

    if (error)
    {
        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
        {
            g_printerr("SSE read error: %s\n", error->message);
        }
        g_clear_error(&error);
        return;
    }

    if (bytes_read <= 0)
    {
        g_print("SSE stream ended\n");
        return;
    }

    char *buffer = (char *)user_data;
    buffer[bytes_read] = '\0';
    sse_buffer += buffer;

    process_sse_buffer();

    sse_read_next_chunk(stream);
}

static void on_sse_send_complete(GObject *source, GAsyncResult *result, gpointer user_data)
{
    SoupSession *session = SOUP_SESSION(source);
    GError *error = NULL;

    GInputStream *stream = soup_session_send_finish(session, result, &error);

    if (error)
    {
        g_printerr("SSE connection failed: %s\n", error->message);
        g_clear_error(&error);
        return;
    }

    g_print("SSE stream connected!\n");
    sse_stream = stream;
    sse_buffer.clear();

    sse_read_next_chunk(stream);
}

static void stop_sse_stream()
{
    if (sse_cancellable)
    {
        g_cancellable_cancel(sse_cancellable);
        g_clear_object(&sse_cancellable);
    }

    if (sse_stream)
    {
        g_input_stream_close(sse_stream, NULL, NULL);
        g_clear_object(&sse_stream);
    }

    sse_buffer.clear();
    current_sse_station_id.clear();
}

static void start_sse_stream(const std::string &station_id)
{
    stop_sse_stream();

    current_sse_station_id = station_id;

    if (!sse_session)
    {
        sse_session = soup_session_new();
    }

    char url[256];
    snprintf(url, sizeof(url), "https://airnet.waqi.info/airnet/sse/feed/%s", station_id.c_str());

    g_print("Starting SSE stream: %s\n", url);

    SoupMessage *msg = soup_message_new("GET", url);
    if (!msg)
    {
        g_printerr("Failed to create SSE request\n");
        return;
    }

    soup_message_headers_append(soup_message_get_request_headers(msg), "Accept", "text/event-stream");

    sse_cancellable = g_cancellable_new();

    soup_session_send_async(
        sse_session,
        msg,
        G_PRIORITY_DEFAULT,
        sse_cancellable,
        on_sse_send_complete,
        NULL);

    g_object_unref(msg);
}

static void waqi_fetch_station_data(const std::string &station_id, WAQIStationData &station_data)
{
    station_data.has_data = false;
    station_data.station_id = station_id;
    start_sse_stream(station_id);
    g_print("SSE stream started for station %s\n", station_id.c_str());
}
#endif

// --- Live Data State & Helpers ---

static std::vector<int> history_cpu(24, 0);
static std::vector<int> history_mem(24, 0);
static std::vector<int> history_net(24, 0);
static int live_tick = 0;

#ifdef _WIN32
static unsigned long long FileTimeToInt64(const FILETIME &ft)
{
    return (((unsigned long long)(ft.dwHighDateTime)) << 32) | ((unsigned long long)ft.dwLowDateTime);
}

static double GetCPULoad()
{
    static FILETIME preIdleTime = {0}, preKernelTime = {0}, preUserTime = {0};
    FILETIME idleTime, kernelTime, userTime;

    if (!GetSystemTimes(&idleTime, &kernelTime, &userTime))
        return 0.0;

    unsigned long long idle = FileTimeToInt64(idleTime) - FileTimeToInt64(preIdleTime);
    unsigned long long kernel = FileTimeToInt64(kernelTime) - FileTimeToInt64(preKernelTime);
    unsigned long long user = FileTimeToInt64(userTime) - FileTimeToInt64(preUserTime);

    preIdleTime = idleTime;
    preKernelTime = kernelTime;
    preUserTime = userTime;

    if (kernel + user == 0)
        return 0.0;

    return (double)(kernel + user - idle) * 100.0 / (kernel + user);
}

static double GetMemoryUsage()
{
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&memInfo);
    return (double)memInfo.dwMemoryLoad;
}

static double GetNetworkUsage()
{
    static DWORD last_bytes_in = 0;
    static DWORD last_bytes_out = 0;
    static DWORD last_time = 0;

    MIB_IFTABLE *pIfTable;
    ULONG dwSize = 0;

    if (GetIfTable(NULL, &dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER)
    {
        pIfTable = (MIB_IFTABLE *)malloc(dwSize);
    }
    else
    {
        return 0.0;
    }

    if (GetIfTable(pIfTable, &dwSize, FALSE) == NO_ERROR)
    {
        DWORD total_in = 0;
        DWORD total_out = 0;

        for (int i = 0; i < pIfTable->dwNumEntries; i++)
        {
            if (pIfTable->table[i].dwType != MIB_IF_TYPE_LOOPBACK)
            {
                total_in += pIfTable->table[i].dwInOctets;
                total_out += pIfTable->table[i].dwOutOctets;
            }
        }

        DWORD current_time = GetTickCount();
        double speed = 0.0;

        if (last_time != 0)
        {
            double time_diff = (current_time - last_time) / 1000.0;
            if (time_diff > 0)
            {
                long long diff_in = (long long)total_in - last_bytes_in;
                if (diff_in < 0)
                    diff_in += 0xFFFFFFFF;
                long long diff_out = (long long)total_out - last_bytes_out;
                if (diff_out < 0)
                    diff_out += 0xFFFFFFFF;

                double bytes_diff = (double)(diff_in + diff_out);
                speed = (bytes_diff * 8) / (1024.0 * 1024.0); // Mbps
                speed = speed / time_diff;
            }
        }

        last_bytes_in = total_in;
        last_bytes_out = total_out;
        last_time = current_time;

        free(pIfTable);
        return speed;
    }

    free(pIfTable);
    return 0.0;
}
#else
static double GetCPULoad() { return (rand() % 100); }
static double GetMemoryUsage() { return 50.0; }
static double GetNetworkUsage() { return (rand() % 100); }
#endif

static AirQualityData get_live_data(const char *type)
{
    AirQualityData data;
    data.city = type;
    data.status = "Live";

    if (strstr(type, "CPU"))
    {
        data.history = history_cpu;
        data.aqi = history_cpu.empty() ? 0 : history_cpu.back();
    }
    else if (strstr(type, "Mem"))
    {
        data.history = history_mem;
        data.aqi = history_mem.empty() ? 0 : history_mem.back();
    }
    else
    {
        data.history = history_net;
        data.aqi = history_net.empty() ? 0 : history_net.back();
    }

    data.pm25 = data.aqi * 0.5;
    data.pm10 = data.aqi * 1.1;

    return data;
}

// --- Interaction Callbacks ---

static void on_chart_motion(GtkEventControllerMotion *controller, double x, double y, gpointer user_data)
{
    GtkWidget *widget = GTK_WIDGET(user_data);
    g_object_set_data(G_OBJECT(widget), "hover_x", (gpointer)(intptr_t)x);
    g_object_set_data(G_OBJECT(widget), "is_hovering", (gpointer)1);
    gtk_widget_queue_draw(widget);
}

static void on_chart_leave(GtkEventControllerMotion *controller, gpointer user_data)
{
    GtkWidget *widget = GTK_WIDGET(user_data);
    g_object_set_data(G_OBJECT(widget), "is_hovering", (gpointer)0);
    gtk_widget_queue_draw(widget);
}

// --- Drawing Callback ---

static void on_draw_chart(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer user_data)
{
    const char *city_name = (const char *)g_object_get_data(G_OBJECT(area), "city_name");
    gpointer is_live = g_object_get_data(G_OBJECT(area), "is_live");

    AirQualityData data_to_draw;

    if (is_live)
    {
        const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
        data_to_draw = get_live_data(type ? type : "Unknown");
    }
    else if (city_name)
    {
        data_to_draw = get_mock_data(city_name);
    }
    else
    {
        if (current_aqi_data.history.empty())
            return;
        data_to_draw = current_aqi_data;
    }

    if (data_to_draw.history.empty())
        return;

    cairo_set_source_rgb(cr, 0.95, 0.95, 0.95);
    cairo_paint(cr);

    double margin_x = 40.0;
    double margin_y = 20.0;
    double graph_w = width - margin_x - 20.0;
    double graph_h = height - 2 * margin_y;

    int max_val = 0;
    for (int val : data_to_draw.history)
    {
        if (val > max_val)
            max_val = val;
    }
    if (max_val < 100)
        max_val = 100;

    cairo_set_line_width(cr, 1.0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 10);

    for (int i = 0; i <= 4; i++)
    {
        double y = margin_y + graph_h - (i * graph_h / 4.0);

        cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1.0);
        cairo_move_to(cr, margin_x, y);
        cairo_line_to(cr, margin_x + graph_w, y);
        cairo_stroke(cr);

        char label[16];
        snprintf(label, sizeof(label), "%d", max_val * i / 4);
        cairo_text_extents_t extents;
        cairo_text_extents(cr, label, &extents);

        cairo_set_source_rgb(cr, 0.4, 0.4, 0.4);
        cairo_move_to(cr, margin_x - extents.width - 5, y + extents.height / 2 - 2);
        cairo_show_text(cr, label);
    }

    cairo_set_source_rgb(cr, 0.2, 0.6, 1.0);
    cairo_set_line_width(cr, 3.0);

    double step_x = graph_w / (data_to_draw.history.size() - 1);

    for (size_t i = 0; i < data_to_draw.history.size(); i++)
    {
        double x = margin_x + i * step_x;
        double y = margin_y + graph_h - (data_to_draw.history[i] / (double)max_val * graph_h);

        if (i == 0)
            cairo_move_to(cr, x, y);
        else
            cairo_line_to(cr, x, y);
    }
    cairo_stroke_preserve(cr);

    cairo_line_to(cr, margin_x + graph_w, margin_y + graph_h);
    cairo_line_to(cr, margin_x, margin_y + graph_h);
    cairo_close_path(cr);

    cairo_pattern_t *pat = cairo_pattern_create_linear(0, margin_y, 0, margin_y + graph_h);
    cairo_pattern_add_color_stop_rgba(pat, 0, 0.2, 0.6, 1.0, 0.4);
    cairo_pattern_add_color_stop_rgba(pat, 1, 0.2, 0.6, 1.0, 0.0);
    cairo_set_source(cr, pat);
    cairo_fill(cr);
    cairo_pattern_destroy(pat);

    if (is_live && !data_to_draw.history.empty())
    {
        int current_val = data_to_draw.history.back();
        const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
        char label_text[64];

        if (type && (strstr(type, "CPU") || strstr(type, "Memory")))
        {
            snprintf(label_text, sizeof(label_text), "%d%%", current_val);
        }
        else if (type && strstr(type, "Network"))
        {
            snprintf(label_text, sizeof(label_text), "%.1f Mbps", (double)current_val);
        }
        else
        {
            snprintf(label_text, sizeof(label_text), "%d", current_val);
        }

        cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
        cairo_set_font_size(cr, 24);
        cairo_text_extents_t extents;
        cairo_text_extents(cr, label_text, &extents);

        double x = width - margin_x - extents.width;
        double y = margin_y + extents.height;

        cairo_set_source_rgba(cr, 0.1, 0.1, 0.1, 0.8);
        cairo_move_to(cr, x, y);
        cairo_show_text(cr, label_text);
    }

    gpointer is_hovering = g_object_get_data(G_OBJECT(area), "is_hovering");
    if (is_hovering)
    {
        int mouse_x = (int)(intptr_t)g_object_get_data(G_OBJECT(area), "hover_x");

        int index = -1;
        double min_dist = 9999;

        for (size_t i = 0; i < data_to_draw.history.size(); i++)
        {
            double x = margin_x + i * step_x;
            double dist = fabs(x - mouse_x);
            if (dist < min_dist)
            {
                min_dist = dist;
                index = i;
            }
        }

        if (index >= 0 && min_dist < step_x / 1.5)
        {
            double x = margin_x + index * step_x;
            double y = margin_y + graph_h - (data_to_draw.history[index] / (double)max_val * graph_h);

            cairo_set_source_rgba(cr, 0.5, 0.5, 0.5, 0.8);
            cairo_set_line_width(cr, 1.0);
            double dashes[] = {4.0};
            cairo_set_dash(cr, dashes, 1, 0);
            cairo_move_to(cr, x, margin_y);
            cairo_line_to(cr, x, margin_y + graph_h);
            cairo_stroke(cr);
            cairo_set_dash(cr, NULL, 0, 0);

            cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
            cairo_arc(cr, x, y, 5, 0, 2 * 3.14159);
            cairo_fill_preserve(cr);
            cairo_set_source_rgb(cr, 0.2, 0.6, 1.0);
            cairo_set_line_width(cr, 2.0);
            cairo_stroke(cr);

            char tooltip[32];
            const char *unit = "";
            if (is_live)
            {
                const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
                if (type && strstr(type, "Network"))
                    unit = " Mbps";
                else if (type && (strstr(type, "CPU") || strstr(type, "Memory")))
                    unit = "%";
            }
            snprintf(tooltip, sizeof(tooltip), "%d%s", data_to_draw.history[index], unit);

            cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
            cairo_set_font_size(cr, 10);
            cairo_text_extents_t extents;
            cairo_text_extents(cr, tooltip, &extents);

            double box_w = extents.width + 10;
            double box_h = extents.height + 10;
            double box_x = x + 10;
            double box_y = y - 10 - box_h;

            if (box_x + box_w > width - 20)
                box_x = x - 10 - box_w;
            if (box_y < margin_y)
                box_y = y + 10;

            cairo_set_source_rgba(cr, 0.2, 0.2, 0.2, 0.9);
            cairo_rectangle(cr, box_x, box_y, box_w, box_h);
            cairo_fill(cr);

            cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
            cairo_move_to(cr, box_x + 5, box_y + box_h - 5);
            cairo_show_text(cr, tooltip);
        }
    }
}

// --- Callbacks ---

#ifndef __ANDROID__
static gboolean do_search_callback(gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);
    search_timeout_id = 0;

    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (!entry_obj)
        return FALSE;

    const char *query = gtk_editable_get_text(GTK_EDITABLE(entry_obj));
    if (query && strlen(query) >= 2)
    {
        waqi_search_cities_async(query, builder, SEARCH_MODE_DROPDOWN);
    }
    else
    {
        waqi_search_cities_async(query, builder, SEARCH_MODE_DROPDOWN);
    }

    return FALSE;
}

static void on_city_entry_changed(GtkEditable *editable, gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);

    if (search_timeout_id > 0)
    {
        g_source_remove(search_timeout_id);
        search_timeout_id = 0;
    }

    search_timeout_id = g_timeout_add(300, do_search_callback, builder);
}

static void on_search_result_selected(GtkListBox *box, GtkListBoxRow *row, gpointer user_data)
{
    if (!row)
        return;
    GtkBuilder *builder = GTK_BUILDER(user_data);

    int idx = gtk_list_box_row_get_index(row);
    select_search_result_by_index(builder, idx);
}

static void populate_search_dropdown(GtkBuilder *builder)
{
    GObject *dropdown_obj = gtk_builder_get_object(builder, "search_dropdown");
    GObject *listbox_obj = gtk_builder_get_object(builder, "search_results_list");

    if (!dropdown_obj || !listbox_obj)
    {
        g_print("Search dropdown UI elements not found!\n");
        return;
    }

    GtkListBox *listbox = GTK_LIST_BOX(listbox_obj);

    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(GTK_WIDGET(listbox))) != NULL)
    {
        gtk_list_box_remove(listbox, child);
    }

    for (const auto &result : search_results)
    {
        GtkWidget *row = gtk_list_box_row_new();
        GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
        gtk_widget_set_margin_start(box, 10);
        gtk_widget_set_margin_end(box, 10);
        gtk_widget_set_margin_top(box, 8);
        gtk_widget_set_margin_bottom(box, 8);

        GtkWidget *info_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
        gtk_widget_set_hexpand(info_box, TRUE);

        GtkWidget *name_label = gtk_label_new(result.station_name.c_str());
        gtk_label_set_xalign(GTK_LABEL(name_label), 0);
        gtk_widget_add_css_class(name_label, "heading");

        char subtitle[256];
        snprintf(subtitle, sizeof(subtitle), "%s â€¢ %s", result.country.c_str(), result.source.c_str());
        GtkWidget *subtitle_label = gtk_label_new(subtitle);
        gtk_label_set_xalign(GTK_LABEL(subtitle_label), 0);
        gtk_widget_add_css_class(subtitle_label, "dim-label");
        gtk_widget_add_css_class(subtitle_label, "caption");

        gtk_box_append(GTK_BOX(info_box), name_label);
        gtk_box_append(GTK_BOX(info_box), subtitle_label);

        GtkWidget *aqi_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        gtk_widget_set_valign(aqi_box, GTK_ALIGN_CENTER);

        char aqi_str[16];
        if (result.has_aqi)
        {
            snprintf(aqi_str, sizeof(aqi_str), "%d", result.aqi);
        }
        else
        {
            snprintf(aqi_str, sizeof(aqi_str), "--");
        }
        GtkWidget *aqi_label = gtk_label_new(aqi_str);
        gtk_widget_add_css_class(aqi_label, "title-2");

        if (result.has_aqi)
        {
            if (result.aqi <= 50)
                gtk_widget_add_css_class(aqi_label, "aqi-good");
            else if (result.aqi <= 100)
                gtk_widget_add_css_class(aqi_label, "aqi-ok");
            else
                gtk_widget_add_css_class(aqi_label, "aqi-bad");
        }

        gtk_box_append(GTK_BOX(aqi_box), aqi_label);

        gtk_box_append(GTK_BOX(box), info_box);
        gtk_box_append(GTK_BOX(box), aqi_box);

        gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(row), box);
        gtk_list_box_append(listbox, row);
    }

    gtk_widget_set_visible(GTK_WIDGET(dropdown_obj), !search_results.empty());
}
#endif

// --- LibSoup Network Test Logic (Added) ---

static void on_network_test_complete(GObject *source, GAsyncResult *result, gpointer user_data)
{
    SoupSession *session = SOUP_SESSION(source);
    GtkWidget *log_view = GTK_WIDGET(user_data);

    GError *error = NULL;
    GBytes *bytes = soup_session_send_and_read_finish(session, result, &error);

    GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(log_view));
    std::string log_text;

    if (error)
    {
        log_text = "ERROR: ";
        log_text += error->message;
        g_error_free(error);
    }
    else
    {
        log_text = "STATUS: Success (200 OK)\n";
        guint status = soup_message_get_status(soup_session_get_async_result_message(session, result));
        char status_buf[64];
        snprintf(status_buf, sizeof(status_buf), "HTTP Status: %u\n", status);
        log_text += status_buf;

        if (bytes)
        {
            gsize size = 0;
            const char *data = (const char *)g_bytes_get_data(bytes, &size);

            if (g_utf8_validate(data, size, NULL))
            {
                log_text += "\n--- RESPONSE BODY ---\n";
                // Truncate if too long
                if (size > 1024)
                {
                    log_text += std::string(data, 1024);
                    log_text += "\n...[truncated]...";
                }
                else
                {
                    log_text += std::string(data, size);
                }
            }
            else
            {
                log_text += "\n[Binary or Invalid UTF-8 Data Received]";
            }
            g_bytes_unref(bytes);
        }
        else
        {
            log_text += "\n(Empty Response Body)";
        }
    }

    gtk_text_buffer_set_text(buffer, log_text.c_str(), -1);
}

static void on_network_test_clicked(GtkButton *button, gpointer user_data)
{
    // user_data is the GtkEntry
    GtkWidget *entry = GTK_WIDGET(user_data);

    // Retrieve the text view from the entry's data
    GtkWidget *log_view = GTK_WIDGET(g_object_get_data(G_OBJECT(entry), "log_view"));
    if (!log_view)
        return;

    const char *url = gtk_editable_get_text(GTK_EDITABLE(entry));
    GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(log_view));

    if (!url || !*url)
    {
        gtk_text_buffer_set_text(buffer, "Error: Please enter a URL.", -1);
        return;
    }

    gtk_text_buffer_set_text(buffer, "Sending request...\nWaiting for response...", -1);

    SoupSession *session = soup_session_new();
    SoupMessage *msg = soup_message_new("GET", url);

    if (!msg)
    {
        gtk_text_buffer_set_text(buffer, "Error: Invalid URL format.", -1);
        g_object_unref(session);
        return;
    }

    soup_session_send_and_read_async(
        session,
        msg,
        G_PRIORITY_DEFAULT,
        NULL,
        on_network_test_complete,
        log_view);

    g_object_unref(msg);
    g_object_unref(session);
}

static void update_aqi_display(GtkBuilder *builder)
{
    GObject *result_box_obj = gtk_builder_get_object(builder, "aqi_result_box");
    if (!result_box_obj)
        return;

    GtkLabel *lbl_city = GTK_LABEL(gtk_builder_get_object(builder, "lbl_city_name"));
    GtkLabel *lbl_aqi = GTK_LABEL(gtk_builder_get_object(builder, "lbl_aqi_value"));
    GtkLabel *lbl_status = GTK_LABEL(gtk_builder_get_object(builder, "lbl_aqi_status"));
    GtkLabel *lbl_pm25 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_pm25"));
    GtkLabel *lbl_pm10 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_pm10"));

    char buffer[64];

    if (lbl_city)
        gtk_label_set_text(lbl_city, current_aqi_data.city);

    if (lbl_aqi)
    {
        snprintf(buffer, sizeof(buffer), "%d", current_aqi_data.aqi);
        gtk_label_set_text(lbl_aqi, buffer);
    }

    if (lbl_status)
        gtk_label_set_text(lbl_status, current_aqi_data.status);

    if (lbl_pm25)
    {
        snprintf(buffer, sizeof(buffer), "PM2.5: %.1f Âµg/mÂ³", current_aqi_data.pm25);
        gtk_label_set_text(lbl_pm25, buffer);
    }

    if (lbl_pm10)
    {
        snprintf(buffer, sizeof(buffer), "PM10: %.1f Âµg/mÂ³", current_aqi_data.pm10);
        gtk_label_set_text(lbl_pm10, buffer);
    }

    GtkLabel *lbl_o3 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_o3"));
    GtkLabel *lbl_no2 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_no2"));
    GtkLabel *lbl_co = GTK_LABEL(gtk_builder_get_object(builder, "lbl_co"));
    GtkLabel *lbl_so2 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_so2"));

    if (lbl_o3 && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "Oâ‚ƒ: %.1f ppb", current_station_data.o3);
        gtk_label_set_text(lbl_o3, buffer);
    }

    if (lbl_no2 && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "NOâ‚‚: %.1f ppb", current_station_data.no2);
        gtk_label_set_text(lbl_no2, buffer);
    }

    if (lbl_co && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "CO: %.1f ppm", current_station_data.co / 1000.0);
        gtk_label_set_text(lbl_co, buffer);
    }

    if (lbl_so2 && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "SOâ‚‚: %.2f ppb", current_station_data.so2);
        gtk_label_set_text(lbl_so2, buffer);
    }

    GtkLabel *lbl_temp = GTK_LABEL(gtk_builder_get_object(builder, "lbl_temperature"));
    GtkLabel *lbl_humidity = GTK_LABEL(gtk_builder_get_object(builder, "lbl_humidity"));
    GtkLabel *lbl_wind = GTK_LABEL(gtk_builder_get_object(builder, "lbl_wind"));

    if (lbl_temp && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "ðŸŒ¡ï¸ %.1fÂ°C", current_station_data.temperature);
        gtk_label_set_text(lbl_temp, buffer);
    }

    if (lbl_humidity && current_station_data.has_data)
    {
        snprintf(buffer, sizeof(buffer), "ðŸ’§ %.0f%%", current_station_data.humidity);
        gtk_label_set_text(lbl_humidity, buffer);
    }

    if (lbl_wind && current_station_data.has_data)
    {
        const char *wind_dir = "";
        int wd = current_station_data.wind_direction;
        if (wd >= 337 || wd < 22)
            wind_dir = "N";
        else if (wd < 67)
            wind_dir = "NE";
        else if (wd < 112)
            wind_dir = "E";
        else if (wd < 157)
            wind_dir = "SE";
        else if (wd < 202)
            wind_dir = "S";
        else if (wd < 247)
            wind_dir = "SW";
        else if (wd < 292)
            wind_dir = "W";
        else
            wind_dir = "NW";
        snprintf(buffer, sizeof(buffer), "ðŸ’¨ %.1f m/s %s", current_station_data.wind_speed, wind_dir);
        gtk_label_set_text(lbl_wind, buffer);
    }

    GtkLabel *lbl_advice = GTK_LABEL(gtk_builder_get_object(builder, "lbl_health_advice"));
    if (lbl_advice)
    {
        const char *advice = "";
        if (current_aqi_data.aqi <= 50)
            advice = "Air quality is good. Enjoy outdoor activities!";
        else if (current_aqi_data.aqi <= 100)
            advice = "Air quality is acceptable. Sensitive groups should limit prolonged outdoor exertion.";
        else if (current_aqi_data.aqi <= 150)
            advice = "Unhealthy for sensitive groups. Reduce prolonged outdoor exertion.";
        else if (current_aqi_data.aqi <= 200)
            advice = "Unhealthy. Everyone may experience health effects.";
        else if (current_aqi_data.aqi <= 300)
            advice = "Very unhealthy. Avoid outdoor activities.";
        else
            advice = "Hazardous! Avoid all outdoor activities.";
        gtk_label_set_text(lbl_advice, advice);
    }

    if (lbl_status)
    {
        GtkWidget *status_widget = GTK_WIDGET(lbl_status);
        gtk_widget_remove_css_class(status_widget, "aqi-good");
        gtk_widget_remove_css_class(status_widget, "aqi-ok");
        gtk_widget_remove_css_class(status_widget, "aqi-bad");

        if (current_aqi_data.aqi <= 50)
            gtk_widget_add_css_class(status_widget, "aqi-good");
        else if (current_aqi_data.aqi <= 100)
            gtk_widget_add_css_class(status_widget, "aqi-ok");
        else
            gtk_widget_add_css_class(status_widget, "aqi-bad");
    }

    gtk_widget_set_visible(GTK_WIDGET(result_box_obj), TRUE);

    GObject *chart_area_obj = gtk_builder_get_object(builder, "chart_area_current");
    if (chart_area_obj)
    {
        gtk_widget_queue_draw(GTK_WIDGET(chart_area_obj));
    }

    GObject *pollutant_box = gtk_builder_get_object(builder, "pollutant_detail_box");
    if (pollutant_box && current_station_data.has_data)
    {
        gtk_widget_set_visible(GTK_WIDGET(pollutant_box), TRUE);
    }

    GObject *weather_box = gtk_builder_get_object(builder, "weather_box");
    if (weather_box && current_station_data.has_data)
    {
        gtk_widget_set_visible(GTK_WIDGET(weather_box), TRUE);
    }
}

static void on_fetch_aqi_clicked(GtkButton *button, gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);

    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (!entry_obj)
        return;

    const char *city = gtk_editable_get_text(GTK_EDITABLE(entry_obj));
    if (!city || !*city)
    {
        city = "Delhi";
    }

#ifndef __ANDROID__
    g_free(g_api_city_name);
    g_api_city_name = g_strdup(city);
    current_aqi_data.city = g_api_city_name;
    current_aqi_data.aqi = 0;
    current_aqi_data.pm25 = 0.0;
    current_aqi_data.pm10 = 0.0;
    current_aqi_data.status = "Searching...";
    current_aqi_data.history.clear();
    for (int i = 0; i < 24; i++)
        current_aqi_data.history.push_back(0);
    update_aqi_display(builder);

    waqi_search_cities_async(city, builder, SEARCH_MODE_AUTO_SELECT_FIRST);
#else
    current_aqi_data = get_mock_data(city);
    update_aqi_display(builder);
#endif
}

static void on_play_clicked(GtkButton *button, gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);
    GObject *entry_obj = gtk_builder_get_object(builder, "url_entry");
    GObject *video_obj = gtk_builder_get_object(builder, "video_player");

    if (!entry_obj || !video_obj)
        return;

    GtkEntry *entry = GTK_ENTRY(entry_obj);
    GtkVideo *video = GTK_VIDEO(video_obj);

    const char *url = gtk_editable_get_text(GTK_EDITABLE(entry));

    if (url && *url)
    {
        GFile *file = g_file_new_for_uri(url);
        gtk_video_set_file(video, file);
        g_object_unref(file);
    }
}

static void on_sidebar_toggle_clicked(GtkToggleButton *button, gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);
    GObject *split_obj = gtk_builder_get_object(builder, "split_view");

    if (!split_obj)
        return;

    gboolean active = gtk_toggle_button_get_active(button);

#ifndef __ANDROID__
    adw_navigation_split_view_set_show_content(ADW_NAVIGATION_SPLIT_VIEW(split_obj), !active);
#else
    GObject *sidebar_obj = gtk_builder_get_object(builder, "sidebar");
    if (sidebar_obj)
    {
        gtk_widget_set_visible(GTK_WIDGET(sidebar_obj), active);
    }
#endif
}

static void on_nav_row_selected(GtkListBox *box, GtkListBoxRow *row, gpointer user_data)
{
    if (!row)
        return;
    GtkBuilder *builder = GTK_BUILDER(user_data);

    GObject *stack_obj = gtk_builder_get_object(builder, "main_stack");
    GObject *split_obj = gtk_builder_get_object(builder, "split_view");
    GObject *title_obj = gtk_builder_get_object(builder, "content_title");

    if (!stack_obj)
        return;

    GtkStack *stack = GTK_STACK(stack_obj);
    int idx = gtk_list_box_row_get_index(row);

    // UPDATED: Added 4th page for Network Test
    const char *page_names[] = {"dashboard", "live_charts", "video", "network_test"};
    const char *titles[] = {"Dashboard", "Live Charts", "Media Player", "LibSoup Test"};
    const char *subtitles[] = {"Air Quality", "System Monitoring", "Video", "Connectivity Check"};

    if (idx >= 0 && idx < 4)
    {
        gtk_stack_set_visible_child_name(stack, page_names[idx]);

        if (title_obj)
        {
            adw_window_title_set_title(ADW_WINDOW_TITLE(title_obj), titles[idx]);
            adw_window_title_set_subtitle(ADW_WINDOW_TITLE(title_obj), subtitles[idx]);
        }

#ifndef __ANDROID__
        if (split_obj && adw_navigation_split_view_get_collapsed(ADW_NAVIGATION_SPLIT_VIEW(split_obj)))
        {
            g_object_set(split_obj, "show-sidebar", FALSE, NULL);
        }
#else
        GObject *sidebar_obj = gtk_builder_get_object(builder, "sidebar");
        if (sidebar_obj)
        {
            gtk_widget_set_visible(GTK_WIDGET(sidebar_obj), FALSE);
        }
#endif
    }
}

static gboolean on_live_tick(gpointer user_data)
{
    GtkBuilder *builder = GTK_BUILDER(user_data);
    live_tick++;

    int cpu = (int)GetCPULoad();
    if (history_cpu.size() >= 24)
        history_cpu.erase(history_cpu.begin());
    history_cpu.push_back(cpu);

    int mem = (int)GetMemoryUsage();
    if (history_mem.size() >= 24)
        history_mem.erase(history_mem.begin());
    history_mem.push_back(mem);

    int net = (int)GetNetworkUsage();
    if (history_net.size() >= 24)
        history_net.erase(history_net.begin());
    history_net.push_back(net);

    const char *ids[] = {"chart_live_cpu", "chart_live_mem", "chart_live_net", NULL};
    for (const char **id = ids; *id; id++)
    {
        GObject *obj = gtk_builder_get_object(builder, *id);
        if (obj)
            gtk_widget_queue_draw(GTK_WIDGET(obj));
    }
    return TRUE;
}

static void load_custom_css()
{
    GtkCssProvider *provider = gtk_css_provider_new();
    const char *css_data =
        "window { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }"
        ".sidebar { background-color: #f8f9fa; border-right: 1px solid #dee2e6; }"
        ".sidebar list { background-color: transparent; }"
        ".sidebar row { padding: 10px 16px; color: #333; font-weight: 500; border-radius: 4px; margin: 2px 8px; }"
        ".sidebar row:selected { color: #0d6efd; background-color: rgba(13, 110, 253, 0.1); }"
        ".navigation-sidebar image { color: #495057; -gtk-icon-style: symbolic; }"
        ".navigation-sidebar row:selected image { color: #0d6efd; }"
        ".dashboard-title { font-size: 28px; font-weight: 600; color: #212529; }"
        ".section-title { font-size: 20px; font-weight: 600; color: #212529; margin-top: 24px; margin-bottom: 16px; border-bottom: 1px solid #dee2e6; padding-bottom: 8px; }"
        ".card { background-color: #fff; border: 1px solid rgba(0,0,0,.125); border-radius: 4px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.02); }"
        ".stat-value { font-size: 28px; font-weight: 700; color: #212529; }"
        ".stat-label { font-size: 13px; color: #6c757d; font-weight: 600; text-transform: uppercase; }"
        ".btn-primary { background-color: #0d6efd; color: white; border-radius: 4px; font-weight: 600; padding: 6px 12px; }"
        ".btn-outline { background-color: white; color: #6c757d; border: 1px solid #6c757d; border-radius: 4px; font-weight: 600; padding: 6px 12px; }"
        ".aqi-good { color: #198754; }"
        ".aqi-ok { color: #fd7e14; }"
        ".aqi-bad { color: #dc3545; }"
        ".video-card { padding: 0; overflow: hidden; border-radius: 12px; }"
        ".video-card video { border-radius: 12px; background: #000; min-height: 200px; }";
    gtk_css_provider_load_from_string(provider, css_data);

    GdkDisplay *display = gdk_display_get_default();
    if (display)
    {
        gtk_style_context_add_provider_for_display(display,
                                                   GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    }
    g_object_unref(provider);
}

// Function to programmatically build the Network Test page since we cannot modify layout.ui
static void setup_network_test_ui(GtkBuilder *builder)
{
    // 1. Add Sidebar Item
    GObject *nav_list_obj = gtk_builder_get_object(builder, "nav_list");
    if (nav_list_obj)
    {
        GtkWidget *row = gtk_list_box_row_new();
        GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
        gtk_widget_set_margin_top(box, 8);
        gtk_widget_set_margin_bottom(box, 8);
        gtk_widget_set_margin_start(box, 8);
        gtk_widget_set_margin_end(box, 8);

        GtkWidget *icon = gtk_image_new_from_icon_name("network-transmit-receive-symbolic");
        GtkWidget *label = gtk_label_new("LibSoup Test");
        gtk_widget_set_hexpand(label, TRUE);
        gtk_widget_set_halign(label, GTK_ALIGN_START);

        gtk_box_append(GTK_BOX(box), icon);
        gtk_box_append(GTK_BOX(box), label);
        gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(row), box);

        gtk_list_box_append(GTK_LIST_BOX(nav_list_obj), row);
    }

    // 2. Add Stack Page
    GObject *stack_obj = gtk_builder_get_object(builder, "main_stack");
    if (stack_obj)
    {
        // Main container
        GtkWidget *scroll = gtk_scrolled_window_new();
        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);

        GtkWidget *clamp = adw_clamp_new();
        adw_clamp_set_maximum_size(ADW_CLAMP(clamp), 800);
        gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scroll), clamp);

        GtkWidget *content_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 16);
        gtk_widget_set_margin_top(content_box, 16);
        gtk_widget_set_margin_bottom(content_box, 24);
        gtk_widget_set_margin_start(content_box, 16);
        gtk_widget_set_margin_end(content_box, 16);
        adw_clamp_set_child(ADW_CLAMP(clamp), content_box);

        // Title
        GtkWidget *title = gtk_label_new("LibSoup Connectivity Test");
        gtk_widget_add_css_class(title, "title-1");
        gtk_widget_set_halign(title, GTK_ALIGN_START);
        gtk_box_append(GTK_BOX(content_box), title);

        // Controls
        GtkWidget *ctrl_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
        GtkWidget *entry = gtk_entry_new();
        gtk_entry_set_placeholder_text(GTK_ENTRY(entry), "Enter URL (e.g. https://httpbin.org/get)");
        gtk_editable_set_text(GTK_EDITABLE(entry), "https://httpbin.org/get");
        gtk_widget_set_hexpand(entry, TRUE);

        GtkWidget *btn = gtk_button_new_with_label("Test Request");
        gtk_widget_add_css_class(btn, "suggested-action");

        gtk_box_append(GTK_BOX(ctrl_box), entry);
        gtk_box_append(GTK_BOX(ctrl_box), btn);
        gtk_box_append(GTK_BOX(content_box), ctrl_box);

        // Log output
        GtkWidget *frame = gtk_frame_new(NULL);
        gtk_widget_add_css_class(frame, "card");

        GtkWidget *log_scroll = gtk_scrolled_window_new();
        gtk_widget_set_size_request(log_scroll, -1, 300);

        GtkWidget *log_view = gtk_text_view_new();
        gtk_text_view_set_editable(GTK_TEXT_VIEW(log_view), FALSE);
        gtk_text_view_set_monospace(GTK_TEXT_VIEW(log_view), TRUE);
        gtk_text_view_set_left_margin(GTK_TEXT_VIEW(log_view), 10);
        gtk_text_view_set_right_margin(GTK_TEXT_VIEW(log_view), 10);
        gtk_text_view_set_top_margin(GTK_TEXT_VIEW(log_view), 10);
        gtk_text_view_set_bottom_margin(GTK_TEXT_VIEW(log_view), 10);
        gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(log_view), GTK_WRAP_CHAR);

        gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(log_scroll), log_view);
        gtk_frame_set_child(GTK_FRAME(frame), log_scroll);
        gtk_box_append(GTK_BOX(content_box), frame);

        // Connect Signal
        // Pass the log view as data attached to the entry, so we can access it in callback
        g_object_set_data(G_OBJECT(entry), "log_view", log_view);
        g_signal_connect(btn, "clicked", G_CALLBACK(on_network_test_clicked), entry);

        // Add to stack
        gtk_stack_add_named(GTK_STACK(stack_obj), scroll, "network_test");
    }
}

static void on_activate(GtkApplication *app, gpointer user_data)
{
    adw_init();

    g_type_ensure(ADW_TYPE_APPLICATION_WINDOW);
    g_type_ensure(ADW_TYPE_HEADER_BAR);
    g_type_ensure(ADW_TYPE_CLAMP);
    g_type_ensure(ADW_TYPE_WINDOW_TITLE);

#ifndef __ANDROID__
    g_type_ensure(ADW_TYPE_NAVIGATION_SPLIT_VIEW);
    g_type_ensure(ADW_TYPE_NAVIGATION_PAGE);
    g_type_ensure(ADW_TYPE_TOOLBAR_VIEW);
#else
    g_type_ensure(GTK_TYPE_PANED);
    g_type_ensure(GTK_TYPE_STACK);
    g_type_ensure(GTK_TYPE_BOX);
#endif

#ifdef __ANDROID__
    GResource *resource = resources_get_resource();
    g_resources_register(resource);
#endif

    load_custom_css();
    GtkBuilder *builder = gtk_builder_new();
    GError *error = NULL;

#ifdef __ANDROID__
    if (!gtk_builder_add_from_resource(builder, "/com/example/mygtk4app/layout.ui", &error))
    {
        g_printerr("Error loading layout.ui from resource: %s\n", error->message);
        g_clear_error(&error);
        return;
    }
#else
    if (!gtk_builder_add_from_file(builder, "layout.ui", &error))
    {
        g_printerr("Error loading layout.ui: %s\n", error->message);
        g_clear_error(&error);
        return;
    }
#endif

    GObject *window_obj = gtk_builder_get_object(builder, "window");
    if (!window_obj)
    {
        g_printerr("Error: No 'window' object in layout.ui\n");
        return;
    }

    GtkWindow *window = GTK_WINDOW(window_obj);
    gtk_window_set_application(window, app);

    // Inject the Network Test UI programmatically
    setup_network_test_ui(builder);

    GObject *btn_fetch = gtk_builder_get_object(builder, "btn_fetch_aqi");
    if (btn_fetch)
        g_signal_connect(btn_fetch, "clicked", G_CALLBACK(on_fetch_aqi_clicked), builder);

#ifndef __ANDROID__
    GObject *city_entry = gtk_builder_get_object(builder, "city_entry");
    if (city_entry)
    {
        g_signal_connect(city_entry, "changed", G_CALLBACK(on_city_entry_changed), builder);
    }

    GObject *search_list = gtk_builder_get_object(builder, "search_results_list");
    if (search_list)
    {
        g_signal_connect(search_list, "row-selected", G_CALLBACK(on_search_result_selected), builder);
    }
#endif

    GObject *btn_play = gtk_builder_get_object(builder, "play_button");
    if (btn_play)
        g_signal_connect(btn_play, "clicked", G_CALLBACK(on_play_clicked), builder);

    GObject *sidebar_toggle = gtk_builder_get_object(builder, "sidebar_toggle");
    if (sidebar_toggle)
    {
        g_signal_connect(sidebar_toggle, "toggled", G_CALLBACK(on_sidebar_toggle_clicked), builder);
    }

    GObject *nav_list = gtk_builder_get_object(builder, "nav_list");
    if (nav_list)
    {
        g_signal_connect(nav_list, "row-selected", G_CALLBACK(on_nav_row_selected), builder);
        GtkListBoxRow *first_row = gtk_list_box_get_row_at_index(GTK_LIST_BOX(nav_list), 0);
        if (first_row)
            gtk_list_box_select_row(GTK_LIST_BOX(nav_list), first_row);
    }

    GObject *chart_current = gtk_builder_get_object(builder, "chart_area_current");
    if (chart_current)
    {
        gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(chart_current), on_draw_chart, NULL, NULL);

        GtkEventController *motion = gtk_event_controller_motion_new();
        g_signal_connect(motion, "motion", G_CALLBACK(on_chart_motion), chart_current);
        g_signal_connect(motion, "leave", G_CALLBACK(on_chart_leave), chart_current);
        gtk_widget_add_controller(GTK_WIDGET(chart_current), motion);
    }

    struct LiveChartConfig
    {
        const char *id;
        const char *type;
    };
    LiveChartConfig live_charts[] = {
        {"chart_live_cpu", "CPU Load"},
        {"chart_live_mem", "Memory Usage"},
        {"chart_live_net", "Network Traffic"}};

    for (const auto &cfg : live_charts)
    {
        GObject *obj = gtk_builder_get_object(builder, cfg.id);
        if (obj)
        {
            GtkWidget *w = GTK_WIDGET(obj);
            g_object_set_data(G_OBJECT(w), "is_live", (gpointer)1);
            g_object_set_data(G_OBJECT(w), "live_type", (gpointer)cfg.type);
            gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(w), on_draw_chart, NULL, NULL);

            GtkEventController *motion = gtk_event_controller_motion_new();
            g_signal_connect(motion, "motion", G_CALLBACK(on_chart_motion), w);
            g_signal_connect(motion, "leave", G_CALLBACK(on_chart_leave), w);
            gtk_widget_add_controller(w, motion);
        }
    }

    g_timeout_add(1000, on_live_tick, builder);

    gtk_window_present(window);
    g_object_set_data_full(G_OBJECT(window), "builder", builder, g_object_unref);
}

#ifdef __ANDROID__
static char *find_library_path() {
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps) return NULL;

    char line[1024];
    char *found_path = NULL;

    while (fgets(line, sizeof(line), maps)) {
        // Look for one of our known libraries
        if (strstr(line, "libadwaita-1.so") || strstr(line, "libgtk-4.so")) {
            // Parse the path from the line (e.g., ... /data/app/xx/lib/arm64/libadwaita-1.so)
            char *path_start = strchr(line, '/');
            if (path_start) {
                // Find the end of the path
                char *path_end = strchr(path_start, '\n');
                if (path_end) *path_end = '\0';
                
                // Get the directory component
                char *last_slash = strrchr(path_start, '/');
                if (last_slash) {
                    *last_slash = '\0'; // Cut off the filename
                    found_path = g_strdup(path_start);
                    break;
                }
            }
        }
    }
    fclose(maps);
    return found_path;
}
#endif

int main(int argc, char *argv[])
{
#ifndef __ANDROID__
    g_setenv("GTK_MEDIA_DRIVER", "gstreamer", TRUE);
    gst_init(&argc, &argv);
#else
// 1. Dynamically find where Android put our libraries
    char *lib_dir = find_library_path();
    
    if (lib_dir == NULL) {
        g_printerr("CRITICAL: Could not find library path in /proc/self/maps! Fallback to legacy.\n");
        lib_dir = g_strdup("/data/data/com.example.mygtk4app/lib");
    }
    
    g_print("FOUND LIBRARY PATH: %s\n", lib_dir);

    // 2. Setup Environment Variables
    g_setenv("GIO_EXTRA_MODULES", lib_dir, TRUE);
    g_setenv("SSL_CERT_DIR", "/system/etc/security/cacerts", TRUE);
    g_setenv("G_MESSAGES_DEBUG", "all", TRUE);

    // 3. CRITICAL FIX: Pre-load OpenSSL Dependencies using the correct path
    char path[512];
    
    // Load libcrypto
    snprintf(path, sizeof(path), "%s/libcrypto.so", lib_dir);
    GModule *mod_crypto = g_module_open(path, G_MODULE_BIND_LAZY);
    if (!mod_crypto) {
        // Try versioned name if base fails (common in some builds)
        snprintf(path, sizeof(path), "%s/libcrypto.so.3", lib_dir);
        mod_crypto = g_module_open(path, G_MODULE_BIND_LAZY);
    }
    
    if (!mod_crypto) {
        g_printerr("Failed to load libcrypto from %s: %s\n", lib_dir, g_module_error());
    } else {
        g_module_make_resident(mod_crypto);
        g_print("Successfully loaded libcrypto\n");
    }

    // Load libssl
    snprintf(path, sizeof(path), "%s/libssl.so", lib_dir);
    GModule *mod_ssl = g_module_open(path, G_MODULE_BIND_LAZY);
    if (!mod_ssl) {
        snprintf(path, sizeof(path), "%s/libssl.so.3", lib_dir);
        mod_ssl = g_module_open(path, G_MODULE_BIND_LAZY);
    }

    if (!mod_ssl) {
        g_printerr("Failed to load libssl from %s: %s\n", lib_dir, g_module_error());
    } else {
        g_module_make_resident(mod_ssl);
        g_print("Successfully loaded libssl\n");
    }
    
    g_free(lib_dir);
#endif

    AdwApplication *app = adw_application_new("com.example.aqi", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(on_activate), NULL);

    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}