#include <gtk/gtk.h>
#include <adwaita.h>
#include <stdio.h>
#ifndef __ANDROID__
#include <gst/gst.h>
#include <libsoup/soup.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <math.h>
#include <map>
#include <string>

// Declare the GResource function (generated by glib-compile-resources)
#ifdef __ANDROID__
extern "C" GResource *resources_get_resource(void);
#endif

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <iphlpapi.h>
#pragma comment(lib, "iphlpapi.lib")
#endif
#include <SDL2/SDL_platform.h>

// --- Data Structures ---

typedef struct {
    const char *city;
    int aqi;
    const char *status;
    double pm25;
    double pm10;
    std::vector<int> history; // 24-hour history
} AirQualityData;

// Extended data from WAQI feed
typedef struct {
    std::string station_id;
    std::string station_name;
    std::string station_url;
    std::string attribution;
    double latitude;
    double longitude;
    
    // Current values (scaled from raw * 100)
    int aqi;
    double pm25;
    double pm10;
    double o3;
    double no2;
    double co;
    double so2;
    
    // Weather data
    double temperature;
    double humidity;
    double wind_speed;
    int wind_direction;
    
    // Hourly history (last 24 hours)
    std::vector<double> pm25_history;
    std::vector<double> pm10_history;
    std::vector<double> o3_history;
    std::vector<double> no2_history;
    
    bool has_data;
} WAQIStationData;

// Search result item
typedef struct {
    std::string station_id;
    std::string station_name;
    std::string full_address;
    std::string url;
    std::string country;
    std::string source;
    int aqi;
    bool has_aqi;
} WAQISearchResult;

// Global state
static AirQualityData current_aqi_data;
static WAQIStationData current_station_data;
static std::vector<WAQISearchResult> search_results;
static GtkBuilder *g_current_builder = NULL;
static char *g_api_city_name = NULL;
static guint search_timeout_id = 0;

// SSE streaming state
static SoupSession *sse_session = NULL;
static GCancellable *sse_cancellable = NULL;
static GInputStream *sse_stream = NULL;
static std::string sse_buffer;
static std::string current_sse_station_id;

// Mock Data Generator
static AirQualityData get_mock_data(const char *city) {
    AirQualityData data;
    data.city = city;
    
    // Simple hash-based randomization for consistent "mock" data per city
    unsigned int hash = 0;
    for (const char *p = city; *p; p++) hash = hash * 31 + *p;
    
    // Use a local seed based on hash for deterministic history
    unsigned int seed = hash;
    auto my_rand = [&seed]() {
        seed = seed * 1103515245 + 12345;
        return (unsigned int)(seed / 65536) % 32768;
    };

    data.aqi = (hash % 300) + 50; // Random AQI between 50 and 350
    
    if (data.aqi <= 50) data.status = "Good ðŸŸ¢";
    else if (data.aqi <= 100) data.status = "Satisfactory ðŸŸ¡";
    else if (data.aqi <= 200) data.status = "Moderate ðŸŸ ";
    else if (data.aqi <= 300) data.status = "Poor ðŸ”´";
    else data.status = "Very Bad ðŸ”´ðŸ”´ðŸ”´";

    data.pm25 = (double)(data.aqi) * 0.6;
    data.pm10 = (double)(data.aqi) * 1.2;
    
    // Generate mock history (24 points)
    data.history.clear();
    int current = data.aqi;
    for (int i = 0; i < 24; i++) {
        // Add some random fluctuation
        int fluctuation = (my_rand() % 41) - 20; // -20 to +20
        int val = current + fluctuation;
        if (val < 0) val = 0;
        data.history.insert(data.history.begin(), val);
        current = val;
    }
    
    return data;
}

// --- WAQI Live Search API Functions ---

#ifndef __ANDROID__
// Simple JSON helper to find a value after a key
static const char* json_find_value(const char* json, const char* key) {
    char search_key[256];
    snprintf(search_key, sizeof(search_key), "\"%s\":", key);
    const char* pos = strstr(json, search_key);
    if (pos) {
        pos += strlen(search_key);
        while (*pos == ' ' || *pos == '\t') pos++;
        return pos;
    }
    return NULL;
}

// Parse integer from JSON position
static int json_parse_int(const char* pos) {
    if (!pos) return 0;
    if (*pos == '"') pos++; // Skip opening quote if string
    return atoi(pos);
}

// Parse double from JSON position
static double json_parse_double(const char* pos) {
    if (!pos) return 0.0;
    if (*pos == '"') pos++;
    return atof(pos);
}

// Extract string value from JSON (up to delimiter)
static std::string json_parse_string(const char* pos, size_t max_len = 256) {
    if (!pos) return "";
    std::string result;
    if (*pos == '"') pos++;
    while (*pos && *pos != '"' && *pos != ',' && *pos != '}' && result.length() < max_len) {
        if (*pos == '\\' && *(pos+1)) {
            pos++; // Skip escape
        }
        result += *pos++;
    }
    return result;
}

// Search for cities using WAQI search API
static void waqi_search_cities(const char* query, std::vector<WAQISearchResult>& results) {
    results.clear();
    
    if (!query || strlen(query) < 2) return;
    
    // Build search URL: https://search.waqi.info/nsearch/world/<query>?n=10
    char *encoded_query = g_uri_escape_string(query, NULL, TRUE);
    char url[512];
    snprintf(url, sizeof(url), "https://search.waqi.info/nsearch/world/%s?n=10", encoded_query);
    g_free(encoded_query);
    
    g_print("WAQI Search: %s\n", url);
    
    SoupSession *session = soup_session_new();
    SoupMessage *msg = soup_message_new("GET", url);
    
    if (!msg) {
        g_object_unref(session);
        return;
    }
    
    GError *error = NULL;
    GBytes *response = soup_session_send_and_read(session, msg, NULL, &error);
    
    if (error) {
        g_printerr("WAQI search failed: %s\n", error->message);
        g_clear_error(&error);
    } else {
        gsize size;
        const char *data = (const char *)g_bytes_get_data(response, &size);
        
        // Parse results array
        // Format: {"results":[{"s":{"a":"216","n":["Name"]},"n":["Full names"],"x":-567958,"c":"IN","$":"Source"},...]}
        const char *results_start = strstr(data, "\"results\":[");
        if (results_start) {
            results_start += 11; // Skip "results":[ 
            
            // Parse each result object
            const char *pos = results_start;
            while (pos && *pos) {
                const char *obj_start = strchr(pos, '{');
                if (!obj_start) break;
                
                // Find matching closing brace (simple approach)
                const char *obj_end = obj_start + 1;
                int brace_count = 1;
                while (*obj_end && brace_count > 0) {
                    if (*obj_end == '{') brace_count++;
                    else if (*obj_end == '}') brace_count--;
                    obj_end++;
                }
                
                if (brace_count != 0) break;
                
                // Extract data from this result
                WAQISearchResult result;
                
                // Get x field (station identifier) 
                const char *x_pos = json_find_value(obj_start, "x");
                int x_val = 0;
                if (x_pos) {
                    x_val = json_parse_int(x_pos);
                }
                
                // Get AQI from "s":{"a":"value"}
                const char *s_pos = strstr(obj_start, "\"s\":{");
                if (s_pos && s_pos < obj_end) {
                    const char *a_pos = strstr(s_pos, "\"a\":\"");
                    if (a_pos && a_pos < obj_end) {
                        a_pos += 5;
                        result.aqi = atoi(a_pos);
                        result.has_aqi = (result.aqi > 0 || *a_pos == '0');
                        if (*a_pos == '-') result.has_aqi = false; // No data
                    }
                    
                    // Get station name from "n":["name"]
                    const char *n_pos = strstr(s_pos, "\"n\":[\"");
                    if (n_pos && n_pos < obj_end) {
                        n_pos += 6;
                        result.station_name = json_parse_string(n_pos);
                    }
                    
                    // Get URL from "u":"..." and extract station ID
                    const char *u_pos = strstr(s_pos, "\"u\":\"");
                    if (u_pos && u_pos < obj_end) {
                        u_pos += 5;
                        result.url = json_parse_string(u_pos);
                        
                        g_print("  Parsed URL: %s\n", result.url.c_str());
                        
                        // Extract station ID from URL - look for @<id> pattern
                        const char *at_pos = strstr(result.url.c_str(), "@");
                        if (at_pos) {
                            result.station_id = at_pos + 1; // Everything after @
                            g_print("  Extracted ID from @: %s\n", result.station_id.c_str());
                        } else if (x_val != 0) {
                            // Fallback to x field - use absolute value
                            result.station_id = std::to_string(x_val > 0 ? x_val : -x_val);
                            g_print("  Using x_val fallback: %s\n", result.station_id.c_str());
                        } else {
                            // Last resort: use the URL path itself
                            result.station_id = result.url;
                            g_print("  Using URL as ID: %s\n", result.station_id.c_str());
                        }
                    } else {
                        // No URL found, use x_val
                        if (x_val != 0) {
                            result.station_id = std::to_string(x_val > 0 ? x_val : -x_val);
                            g_print("  No URL, using x_val: %s\n", result.station_id.c_str());
                        }
                    }
                }
                
                // Get full names array - first item
                const char *names_pos = strstr(obj_start, "\"n\":[\"");
                // Find the one NOT inside "s"
                while (names_pos && names_pos < s_pos) {
                    names_pos = strstr(names_pos + 1, "\"n\":[\"");
                }
                // Skip past s block
                if (s_pos) {
                    const char *after_s = strchr(s_pos + 5, '}');
                    if (after_s) {
                        names_pos = strstr(after_s, "\"n\":[\"");
                        if (names_pos && names_pos < obj_end) {
                            names_pos += 6;
                            result.full_address = json_parse_string(names_pos, 512);
                        }
                    }
                }
                
                // Get country code
                const char *c_pos = json_find_value(obj_start, "c");
                if (c_pos && c_pos < obj_end) {
                    result.country = json_parse_string(c_pos);
                }
                
                // Get source/attribution from "$"
                const char *src_pos = json_find_value(obj_start, "$");
                if (src_pos && src_pos < obj_end) {
                    result.source = json_parse_string(src_pos);
                }
                
                // Add to results if we got valid data
                if (!result.station_id.empty() && !result.station_name.empty()) {
                    results.push_back(result);
                }
                
                pos = obj_end;
            }
        }
        
        g_bytes_unref(response);
    }
    
    g_object_unref(msg);
    g_object_unref(session);
    
    g_print("Found %zu stations\n", results.size());
}

// Forward declarations for SSE
static void update_aqi_display(GtkBuilder *builder);
static void sse_read_next_chunk(GInputStream *stream);

// Parse a single SSE event JSON and update station data
static void parse_sse_event(const char* json_data, size_t len) {
    // Check event type
    const char *type_pos = strstr(json_data, "\"type\":\"");
    if (!type_pos) return;
    
    type_pos += 8;
    
    if (strncmp(type_pos, "meta\"", 5) == 0) {
        g_print("  [SSE] Received meta event\n");
        
        // Parse station name
        const char *name_pos = strstr(json_data, "\"name\":\"");
        if (name_pos) {
            name_pos += 8;
            current_station_data.station_name = json_parse_string(name_pos);
        }
        
        // Parse geo coordinates
        const char *geo_pos = strstr(json_data, "\"geo\":[");
        if (geo_pos) {
            geo_pos += 7;
            current_station_data.latitude = atof(geo_pos);
            const char *comma = strchr(geo_pos, ',');
            if (comma) current_station_data.longitude = atof(comma + 1);
        }
        
        // Parse feed data (current pollutant values)
        const char *feed_pos = strstr(json_data, "\"feed\":{");
        if (feed_pos) {
            const char *pm25_pos = strstr(feed_pos, "\"pm25\":[");
            if (pm25_pos) {
                const char *comma = strchr(pm25_pos + 8, ',');
                if (comma) current_station_data.pm25 = atof(comma + 1) / 100.0;
            }
            
            const char *pm10_pos = strstr(feed_pos, "\"pm10\":[");
            if (pm10_pos) {
                const char *comma = strchr(pm10_pos + 8, ',');
                if (comma) current_station_data.pm10 = atof(comma + 1) / 100.0;
            }
            
            const char *o3_pos = strstr(feed_pos, "\"o3\":[");
            if (o3_pos) {
                const char *comma = strchr(o3_pos + 6, ',');
                if (comma) current_station_data.o3 = atof(comma + 1) / 100.0;
            }
            
            const char *no2_pos = strstr(feed_pos, "\"no2\":[");
            if (no2_pos) {
                const char *comma = strchr(no2_pos + 7, ',');
                if (comma) current_station_data.no2 = atof(comma + 1) / 100.0;
            }
            
            const char *co_pos = strstr(feed_pos, "\"co\":[");
            if (co_pos) {
                const char *comma = strchr(co_pos + 6, ',');
                if (comma) current_station_data.co = atof(comma + 1) / 100.0;
            }
            
            const char *so2_pos = strstr(feed_pos, "\"so2\":[");
            if (so2_pos) {
                const char *comma = strchr(so2_pos + 7, ',');
                if (comma) current_station_data.so2 = atof(comma + 1) / 100.0;
            }
        }
        
        // Calculate AQI from PM2.5
        if (current_station_data.pm25 > 0) {
            double pm = current_station_data.pm25;
            if (pm <= 12.0) current_station_data.aqi = (int)(pm * 50.0 / 12.0);
            else if (pm <= 35.4) current_station_data.aqi = (int)(50 + (pm - 12.0) * 50.0 / 23.4);
            else if (pm <= 55.4) current_station_data.aqi = (int)(100 + (pm - 35.4) * 50.0 / 20.0);
            else if (pm <= 150.4) current_station_data.aqi = (int)(150 + (pm - 55.4) * 50.0 / 95.0);
            else if (pm <= 250.4) current_station_data.aqi = (int)(200 + (pm - 150.4) * 100.0 / 100.0);
            else if (pm <= 350.4) current_station_data.aqi = (int)(300 + (pm - 250.4) * 100.0 / 100.0);
            else current_station_data.aqi = (int)(400 + (pm - 350.4) * 100.0 / 150.0);
        }
        
        current_station_data.has_data = true;
        
        g_print("  [SSE] PM2.5=%.1f, PM10=%.1f, AQI=%d\n", 
                current_station_data.pm25, current_station_data.pm10, current_station_data.aqi);
        
    } else if (strncmp(type_pos, "instant\"", 8) == 0) {
        g_print("  [SSE] Received instant update\n");
        
        // Real-time pollutant update
        const char *pm25_pos = strstr(json_data, "\"pm25\":[[");
        if (pm25_pos) {
            const char *comma = strchr(pm25_pos + 9, ',');
            if (comma) {
                double new_pm25 = atof(comma + 1) / 100.0;
                if (new_pm25 != current_station_data.pm25) {
                    current_station_data.pm25 = new_pm25;
                    
                    // Recalculate AQI
                    double pm = new_pm25;
                    if (pm <= 12.0) current_station_data.aqi = (int)(pm * 50.0 / 12.0);
                    else if (pm <= 35.4) current_station_data.aqi = (int)(50 + (pm - 12.0) * 50.0 / 23.4);
                    else if (pm <= 55.4) current_station_data.aqi = (int)(100 + (pm - 35.4) * 50.0 / 20.0);
                    else if (pm <= 150.4) current_station_data.aqi = (int)(150 + (pm - 55.4) * 50.0 / 95.0);
                    else if (pm <= 250.4) current_station_data.aqi = (int)(200 + (pm - 150.4) * 100.0 / 100.0);
                    else if (pm <= 350.4) current_station_data.aqi = (int)(300 + (pm - 250.4) * 100.0 / 100.0);
                    else current_station_data.aqi = (int)(400 + (pm - 350.4) * 100.0 / 150.0);
                    
                    g_print("  [SSE] Updated PM2.5=%.1f, AQI=%d\n", new_pm25, current_station_data.aqi);
                }
            }
        }
        
        const char *pm10_pos = strstr(json_data, "\"pm10\":[[");
        if (pm10_pos) {
            const char *comma = strchr(pm10_pos + 9, ',');
            if (comma) current_station_data.pm10 = atof(comma + 1) / 100.0;
        }
        
        const char *o3_pos = strstr(json_data, "\"o3\":[[");
        if (o3_pos) {
            const char *comma = strchr(o3_pos + 7, ',');
            if (comma) current_station_data.o3 = atof(comma + 1) / 100.0;
        }
        
        const char *no2_pos = strstr(json_data, "\"no2\":[[");
        if (no2_pos) {
            const char *comma = strchr(no2_pos + 8, ',');
            if (comma) current_station_data.no2 = atof(comma + 1) / 100.0;
        }
        
        const char *co_pos = strstr(json_data, "\"co\":[[");
        if (co_pos) {
            const char *comma = strchr(co_pos + 7, ',');
            if (comma) current_station_data.co = atof(comma + 1) / 100.0;
        }
        
        const char *so2_pos = strstr(json_data, "\"so2\":[[");
        if (so2_pos) {
            const char *comma = strchr(so2_pos + 8, ',');
            if (comma) current_station_data.so2 = atof(comma + 1) / 100.0;
        }
        
    } else if (strncmp(type_pos, "cwop\"", 5) == 0) {
        g_print("  [SSE] Received weather data\n");
        
        // Parse weather from cwop - find the latest entry
        const char *data_pos = strstr(json_data, "\"data\":{");
        if (data_pos) {
            // Find last temperature entry
            const char *last_t = NULL;
            const char *search = data_pos;
            while ((search = strstr(search, "\"t\":")) != NULL) {
                if (search > data_pos && *(search-1) == ',') {
                    last_t = search;
                }
                search += 4;
            }
            
            if (last_t) {
                current_station_data.temperature = json_parse_double(last_t + 4);
                
                // Find entry boundaries
                const char *entry_start = last_t;
                while (entry_start > data_pos && *entry_start != '{') entry_start--;
                const char *entry_end = strchr(last_t, '}');
                
                if (entry_end) {
                    // Dew point -> humidity
                    const char *dew_pos = strstr(entry_start, "\"dew\":");
                    if (dew_pos && dew_pos < entry_end) {
                        double dew = json_parse_double(dew_pos + 6);
                        double t = current_station_data.temperature;
                        current_station_data.humidity = 100.0 * exp((17.625 * dew) / (243.04 + dew)) / exp((17.625 * t) / (243.04 + t));
                        if (current_station_data.humidity > 100) current_station_data.humidity = 100;
                        if (current_station_data.humidity < 0) current_station_data.humidity = 0;
                    }
                    
                    // Wind
                    const char *w_pos = strstr(entry_start, "\"w\":");
                    if (w_pos && w_pos < entry_end) {
                        current_station_data.wind_speed = json_parse_double(w_pos + 4);
                    }
                    
                    const char *wd_pos = strstr(entry_start, "\"wd\":");
                    if (wd_pos && wd_pos < entry_end) {
                        current_station_data.wind_direction = json_parse_int(wd_pos + 5);
                    }
                }
                
                g_print("  [SSE] Weather: %.1fÂ°C, %.0f%% humidity\n", 
                        current_station_data.temperature, current_station_data.humidity);
            }
        }
        
    } else if (strncmp(type_pos, "hourly\"", 7) == 0) {
        g_print("  [SSE] Received hourly history\n");
        
        // Parse PM2.5 hourly for chart
        const char *pm25_hourly = strstr(json_data, "\"pm25\":[{");
        if (pm25_hourly) {
            current_station_data.pm25_history.clear();
            const char *pos = pm25_hourly + 9;
            int count = 0;
            while (pos && count < 24) {
                const char *mean_pos = strstr(pos, "\"mean\":");
                if (!mean_pos) break;
                double val = json_parse_double(mean_pos + 7);
                current_station_data.pm25_history.push_back(val);
                pos = strchr(mean_pos, '}');
                if (pos) pos++;
                count++;
            }
            g_print("  [SSE] Got %zu hourly PM2.5 values\n", current_station_data.pm25_history.size());
        }
    }
    
    // Update UI on main thread
    if (g_current_builder && current_station_data.has_data) {
        // Update legacy data structure
        current_aqi_data.aqi = current_station_data.aqi;
        current_aqi_data.pm25 = current_station_data.pm25;
        current_aqi_data.pm10 = current_station_data.pm10;
        
        // Update status
        if (current_aqi_data.aqi <= 50) current_aqi_data.status = "Good ðŸŸ¢";
        else if (current_aqi_data.aqi <= 100) current_aqi_data.status = "Satisfactory ðŸŸ¡";
        else if (current_aqi_data.aqi <= 150) current_aqi_data.status = "Moderate ðŸŸ ";
        else if (current_aqi_data.aqi <= 200) current_aqi_data.status = "Unhealthy ðŸŸ ";
        else if (current_aqi_data.aqi <= 300) current_aqi_data.status = "Very Unhealthy ðŸ”´";
        else current_aqi_data.status = "Hazardous â˜ ï¸";
        
        // Update chart history
        if (!current_station_data.pm25_history.empty()) {
            current_aqi_data.history.clear();
            for (double val : current_station_data.pm25_history) {
                current_aqi_data.history.push_back((int)val);
            }
        }
        while (current_aqi_data.history.size() < 24) {
            current_aqi_data.history.insert(current_aqi_data.history.begin(), current_aqi_data.aqi);
        }
        
        update_aqi_display(g_current_builder);
    }
}

// Process SSE buffer - extract complete events
static void process_sse_buffer() {
    // SSE format: "event: message\ndata: {...}\n\n"
    size_t pos = 0;
    while (pos < sse_buffer.size()) {
        // Find end of SSE message (double newline)
        size_t end = sse_buffer.find("\n\n", pos);
        if (end == std::string::npos) break;
        
        std::string message = sse_buffer.substr(pos, end - pos);
        pos = end + 2;
        
        // Extract data line
        size_t data_pos = message.find("data: ");
        if (data_pos != std::string::npos) {
            std::string json_data = message.substr(data_pos + 6);
            // Remove any trailing newlines
            while (!json_data.empty() && (json_data.back() == '\n' || json_data.back() == '\r')) {
                json_data.pop_back();
            }
            
            if (!json_data.empty()) {
                parse_sse_event(json_data.c_str(), json_data.size());
            }
        }
    }
    
    // Keep remaining incomplete data in buffer
    if (pos > 0) {
        sse_buffer = sse_buffer.substr(pos);
    }
}

// Callback when SSE data is received
static void on_sse_read_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
    GInputStream *stream = G_INPUT_STREAM(source);
    GError *error = NULL;
    
    gssize bytes_read = g_input_stream_read_finish(stream, result, &error);
    
    if (error) {
        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
            g_printerr("SSE read error: %s\n", error->message);
        }
        g_clear_error(&error);
        return;
    }
    
    if (bytes_read <= 0) {
        g_print("SSE stream ended\n");
        return;
    }
    
    // Append received data to buffer
    char *buffer = (char *)user_data;
    buffer[bytes_read] = '\0';
    sse_buffer += buffer;
    
    // Process complete events
    process_sse_buffer();
    
    // Continue reading
    sse_read_next_chunk(stream);
}

// Read next chunk from SSE stream
static void sse_read_next_chunk(GInputStream *stream) {
    static char read_buffer[8192];
    
    g_input_stream_read_async(
        stream,
        read_buffer,
        sizeof(read_buffer) - 1,
        G_PRIORITY_DEFAULT,
        sse_cancellable,
        on_sse_read_complete,
        read_buffer
    );
}

// Callback when SSE connection is established
static void on_sse_send_complete(GObject *source, GAsyncResult *result, gpointer user_data) {
    SoupSession *session = SOUP_SESSION(source);
    GError *error = NULL;
    
    GInputStream *stream = soup_session_send_finish(session, result, &error);
    
    if (error) {
        g_printerr("SSE connection failed: %s\n", error->message);
        g_clear_error(&error);
        return;
    }
    
    g_print("SSE stream connected!\n");
    sse_stream = stream;
    sse_buffer.clear();
    
    // Start reading
    sse_read_next_chunk(stream);
}

// Stop current SSE stream
static void stop_sse_stream() {
    if (sse_cancellable) {
        g_cancellable_cancel(sse_cancellable);
        g_clear_object(&sse_cancellable);
    }
    
    if (sse_stream) {
        g_input_stream_close(sse_stream, NULL, NULL);
        g_clear_object(&sse_stream);
    }
    
    sse_buffer.clear();
    current_sse_station_id.clear();
}

// Start SSE stream for a station
static void start_sse_stream(const std::string& station_id) {
    // Stop any existing stream
    stop_sse_stream();
    
    current_sse_station_id = station_id;
    
    // Create session if needed
    if (!sse_session) {
        sse_session = soup_session_new();
    }
    
    // Build feed URL
    char url[256];
    snprintf(url, sizeof(url), "https://airnet.waqi.info/airnet/sse/feed/%s", station_id.c_str());
    
    g_print("Starting SSE stream: %s\n", url);
    
    SoupMessage *msg = soup_message_new("GET", url);
    if (!msg) {
        g_printerr("Failed to create SSE request\n");
        return;
    }
    
    // Set headers for SSE
    soup_message_headers_append(soup_message_get_request_headers(msg), "Accept", "text/event-stream");
    
    // Create cancellable for this stream
    sse_cancellable = g_cancellable_new();
    
    // Start async request
    soup_session_send_async(
        sse_session,
        msg,
        G_PRIORITY_DEFAULT,
        sse_cancellable,
        on_sse_send_complete,
        NULL
    );
    
    g_object_unref(msg);
}

// Legacy synchronous fetch (fallback)
static void waqi_fetch_station_data(const std::string& station_id, WAQIStationData& station_data) {
    station_data.has_data = false;
    station_data.station_id = station_id;
    
    // Start SSE stream instead of blocking fetch
    start_sse_stream(station_id);
    
    // For initial data, we need to wait briefly or use the data from search
    g_print("SSE stream started for station %s\n", station_id.c_str());
}
#endif

// --- Live Data State & Helpers ---

static std::vector<int> history_cpu(24, 0);
static std::vector<int> history_mem(24, 0);
static std::vector<int> history_net(24, 0);
static int live_tick = 0;

#ifdef _WIN32
static unsigned long long FileTimeToInt64(const FILETIME & ft) {
    return (((unsigned long long)(ft.dwHighDateTime)) << 32) | ((unsigned long long)ft.dwLowDateTime);
}

static double GetCPULoad() {
    static FILETIME preIdleTime = {0}, preKernelTime = {0}, preUserTime = {0};
    FILETIME idleTime, kernelTime, userTime;
    
    if (!GetSystemTimes(&idleTime, &kernelTime, &userTime)) return 0.0;

    unsigned long long idle = FileTimeToInt64(idleTime) - FileTimeToInt64(preIdleTime);
    unsigned long long kernel = FileTimeToInt64(kernelTime) - FileTimeToInt64(preKernelTime);
    unsigned long long user = FileTimeToInt64(userTime) - FileTimeToInt64(preUserTime);

    preIdleTime = idleTime;
    preKernelTime = kernelTime;
    preUserTime = userTime;

    if (kernel + user == 0) return 0.0;
    
    return (double)(kernel + user - idle) * 100.0 / (kernel + user);
}

static double GetMemoryUsage() {
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&memInfo);
    return (double)memInfo.dwMemoryLoad;
}

static double GetNetworkUsage() {
    static DWORD last_bytes_in = 0;
    static DWORD last_bytes_out = 0;
    static DWORD last_time = 0;
    
    MIB_IFTABLE *pIfTable;
    ULONG dwSize = 0;
    
    if (GetIfTable(NULL, &dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER) {
        pIfTable = (MIB_IFTABLE *)malloc(dwSize);
    } else {
        return 0.0;
    }
    
    if (GetIfTable(pIfTable, &dwSize, FALSE) == NO_ERROR) {
        DWORD total_in = 0;
        DWORD total_out = 0;
        
        for (int i = 0; i < pIfTable->dwNumEntries; i++) {
            if (pIfTable->table[i].dwType != MIB_IF_TYPE_LOOPBACK) {
                total_in += pIfTable->table[i].dwInOctets;
                total_out += pIfTable->table[i].dwOutOctets;
            }
        }
        
        DWORD current_time = GetTickCount();
        double speed = 0.0;
        
        if (last_time != 0) {
            double time_diff = (current_time - last_time) / 1000.0;
            if (time_diff > 0) {
                long long diff_in = (long long)total_in - last_bytes_in;
                if (diff_in < 0) diff_in += 0xFFFFFFFF;
                long long diff_out = (long long)total_out - last_bytes_out;
                if (diff_out < 0) diff_out += 0xFFFFFFFF;
                
                double bytes_diff = (double)(diff_in + diff_out);
                speed = (bytes_diff * 8) / (1024.0 * 1024.0); // Mbps
                speed = speed / time_diff;
            }
        }
        
        last_bytes_in = total_in;
        last_bytes_out = total_out;
        last_time = current_time;
        
        free(pIfTable);
        return speed;
    }
    
    free(pIfTable);
    return 0.0;
}
#else
static double GetCPULoad() { return (rand() % 100); } 
static double GetMemoryUsage() { return 50.0; }
static double GetNetworkUsage() { return (rand() % 100); }
#endif

static AirQualityData get_live_data(const char *type) {
    AirQualityData data;
    data.city = type;
    data.status = "Live";
    
    if (strstr(type, "CPU")) {
        data.history = history_cpu;
        data.aqi = history_cpu.empty() ? 0 : history_cpu.back();
    } else if (strstr(type, "Mem")) {
        data.history = history_mem;
        data.aqi = history_mem.empty() ? 0 : history_mem.back();
    } else {
        data.history = history_net;
        data.aqi = history_net.empty() ? 0 : history_net.back();
    }
    
    data.pm25 = data.aqi * 0.5;
    data.pm10 = data.aqi * 1.1;
    
    return data;
}

// --- Interaction Callbacks ---

static void on_chart_motion(GtkEventControllerMotion *controller, double x, double y, gpointer user_data) {
    GtkWidget *widget = GTK_WIDGET(user_data);
    g_object_set_data(G_OBJECT(widget), "hover_x", (gpointer)(intptr_t)x);
    g_object_set_data(G_OBJECT(widget), "is_hovering", (gpointer)1);
    gtk_widget_queue_draw(widget);
}

static void on_chart_leave(GtkEventControllerMotion *controller, gpointer user_data) {
    GtkWidget *widget = GTK_WIDGET(user_data);
    g_object_set_data(G_OBJECT(widget), "is_hovering", (gpointer)0);
    gtk_widget_queue_draw(widget);
}

// --- Drawing Callback ---

static void on_draw_chart(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer user_data) {
    // Determine which city to draw based on user_data or widget name
    // For simplicity, we'll check the widget name or data attached to it
    const char *city_name = (const char *)g_object_get_data(G_OBJECT(area), "city_name");
    gpointer is_live = g_object_get_data(G_OBJECT(area), "is_live");
    
    AirQualityData data_to_draw;
    
    if (is_live) {
        const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
        data_to_draw = get_live_data(type ? type : "Unknown");
    } else if (city_name) {
        // If a specific city is attached, fetch its data
        data_to_draw = get_mock_data(city_name);
    } else {
        // Otherwise use the currently selected city data
        if (current_aqi_data.history.empty()) return;
        data_to_draw = current_aqi_data;
    }

    if (data_to_draw.history.empty()) return;

    // Background
    cairo_set_source_rgb(cr, 0.95, 0.95, 0.95);
    cairo_paint(cr);

    // Margins
    double margin_x = 40.0;
    double margin_y = 20.0;
    double graph_w = width - margin_x - 20.0;
    double graph_h = height - 2 * margin_y;

    // Find max value for scaling
    int max_val = 0;
    for (int val : data_to_draw.history) {
        if (val > max_val) max_val = val;
    }
    if (max_val < 100) max_val = 100; // Minimum scale

    // Draw Grid Lines & Labels
    cairo_set_line_width(cr, 1.0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 10);

    for (int i = 0; i <= 4; i++) {
        double y = margin_y + graph_h - (i * graph_h / 4.0);
        
        // Grid line
        cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1.0);
        cairo_move_to(cr, margin_x, y);
        cairo_line_to(cr, margin_x + graph_w, y);
        cairo_stroke(cr);
        
        // Label
        char label[16];
        snprintf(label, sizeof(label), "%d", max_val * i / 4);
        cairo_text_extents_t extents;
        cairo_text_extents(cr, label, &extents);
        
        cairo_set_source_rgb(cr, 0.4, 0.4, 0.4);
        cairo_move_to(cr, margin_x - extents.width - 5, y + extents.height/2 - 2);
        cairo_show_text(cr, label);
    }

    // Draw Graph Line
    cairo_set_source_rgb(cr, 0.2, 0.6, 1.0); // Blue
    cairo_set_line_width(cr, 3.0);
    
    double step_x = graph_w / (data_to_draw.history.size() - 1);
    
    // Path for line
    for (size_t i = 0; i < data_to_draw.history.size(); i++) {
        double x = margin_x + i * step_x;
        double y = margin_y + graph_h - (data_to_draw.history[i] / (double)max_val * graph_h);
        
        if (i == 0) cairo_move_to(cr, x, y);
        else cairo_line_to(cr, x, y);
    }
    cairo_stroke_preserve(cr); // Keep path for fill

    // Fill Gradient
    cairo_line_to(cr, margin_x + graph_w, margin_y + graph_h);
    cairo_line_to(cr, margin_x, margin_y + graph_h);
    cairo_close_path(cr);
    
    cairo_pattern_t *pat = cairo_pattern_create_linear(0, margin_y, 0, margin_y + graph_h);
    cairo_pattern_add_color_stop_rgba(pat, 0, 0.2, 0.6, 1.0, 0.4);
    cairo_pattern_add_color_stop_rgba(pat, 1, 0.2, 0.6, 1.0, 0.0);
    cairo_set_source(cr, pat);
    cairo_fill(cr);
    cairo_pattern_destroy(pat);

    // Draw Current Value Label (Top Right)
    if (is_live && !data_to_draw.history.empty()) {
        int current_val = data_to_draw.history.back();
        const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
        char label_text[64];
        
        if (type && (strstr(type, "CPU") || strstr(type, "Memory"))) {
            snprintf(label_text, sizeof(label_text), "%d%%", current_val);
        } else if (type && strstr(type, "Network")) {
            snprintf(label_text, sizeof(label_text), "%.1f Mbps", (double)current_val);
        } else {
            snprintf(label_text, sizeof(label_text), "%d", current_val);
        }
        
        cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
        cairo_set_font_size(cr, 24);
        cairo_text_extents_t extents;
        cairo_text_extents(cr, label_text, &extents);
        
        double x = width - margin_x - extents.width;
        double y = margin_y + extents.height;
        
        cairo_set_source_rgba(cr, 0.1, 0.1, 0.1, 0.8);
        cairo_move_to(cr, x, y);
        cairo_show_text(cr, label_text);
    }

    // Interactive Overlay
    gpointer is_hovering = g_object_get_data(G_OBJECT(area), "is_hovering");
    if (is_hovering) {
        int mouse_x = (int)(intptr_t)g_object_get_data(G_OBJECT(area), "hover_x");
        
        // Find closest index
        int index = -1;
        double min_dist = 9999;
        
        for (size_t i = 0; i < data_to_draw.history.size(); i++) {
            double x = margin_x + i * step_x;
            double dist = fabs(x - mouse_x);
            if (dist < min_dist) {
                min_dist = dist;
                index = i;
            }
        }
        
        if (index >= 0 && min_dist < step_x / 1.5) { // Snap tolerance
            double x = margin_x + index * step_x;
            double y = margin_y + graph_h - (data_to_draw.history[index] / (double)max_val * graph_h);
            
            // Draw vertical line
            cairo_set_source_rgba(cr, 0.5, 0.5, 0.5, 0.8);
            cairo_set_line_width(cr, 1.0);
            double dashes[] = {4.0};
            cairo_set_dash(cr, dashes, 1, 0);
            cairo_move_to(cr, x, margin_y);
            cairo_line_to(cr, x, margin_y + graph_h);
            cairo_stroke(cr);
            cairo_set_dash(cr, NULL, 0, 0); // Reset dash
            
            // Draw point
            cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
            cairo_arc(cr, x, y, 5, 0, 2 * 3.14159);
            cairo_fill_preserve(cr);
            cairo_set_source_rgb(cr, 0.2, 0.6, 1.0);
            cairo_set_line_width(cr, 2.0);
            cairo_stroke(cr);
            
            // Draw Tooltip Box
            char tooltip[32];
            const char* unit = "";
            if (is_live) {
                const char *type = (const char *)g_object_get_data(G_OBJECT(area), "live_type");
                if (type && strstr(type, "Network")) unit = " Mbps";
                else if (type && (strstr(type, "CPU") || strstr(type, "Memory"))) unit = "%";
            }
            snprintf(tooltip, sizeof(tooltip), "%d%s", data_to_draw.history[index], unit);
            
            cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
            cairo_set_font_size(cr, 10);
            cairo_text_extents_t extents;
            cairo_text_extents(cr, tooltip, &extents);
            
            double box_w = extents.width + 10;
            double box_h = extents.height + 10;
            double box_x = x + 10;
            double box_y = y - 10 - box_h;
            
            // Keep tooltip inside bounds
            if (box_x + box_w > width - 20) box_x = x - 10 - box_w;
            if (box_y < margin_y) box_y = y + 10;
            
            cairo_set_source_rgba(cr, 0.2, 0.2, 0.2, 0.9);
            cairo_rectangle(cr, box_x, box_y, box_w, box_h);
            cairo_fill(cr);
            
            cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
            cairo_move_to(cr, box_x + 5, box_y + box_h - 5);
            cairo_show_text(cr, tooltip);
        }
    }
}

// --- Callbacks ---

// Forward declarations for UI update (update_aqi_display declared earlier for SSE)
static void populate_search_dropdown(GtkBuilder *builder);

#ifndef __ANDROID__
// Perform search and populate dropdown
static gboolean do_search_callback(gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    search_timeout_id = 0;
    
    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (!entry_obj) return FALSE;
    
    const char *query = gtk_editable_get_text(GTK_EDITABLE(entry_obj));
    if (query && strlen(query) >= 2) {
        waqi_search_cities(query, search_results);
        populate_search_dropdown(builder);
    }
    
    return FALSE;
}

// Called when user types in the search entry
static void on_city_entry_changed(GtkEditable *editable, gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    
    // Cancel any pending search
    if (search_timeout_id > 0) {
        g_source_remove(search_timeout_id);
        search_timeout_id = 0;
    }
    
    // Schedule a new search after 300ms debounce
    search_timeout_id = g_timeout_add(300, do_search_callback, builder);
}

// Called when a search result is selected
static void on_search_result_selected(GtkListBox *box, GtkListBoxRow *row, gpointer user_data) {
    if (!row) return;
    GtkBuilder *builder = GTK_BUILDER(user_data);
    
    int idx = gtk_list_box_row_get_index(row);
    if (idx < 0 || idx >= (int)search_results.size()) return;
    
    const WAQISearchResult &result = search_results[idx];
    
    g_print("Selected station: %s (ID: %s)\n", result.station_name.c_str(), result.station_id.c_str());
    
    // Update entry with station name
    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (entry_obj) {
        gtk_editable_set_text(GTK_EDITABLE(entry_obj), result.station_name.c_str());
    }
    
    // Hide dropdown
    GObject *dropdown_obj = gtk_builder_get_object(builder, "search_dropdown");
    if (dropdown_obj) {
        gtk_widget_set_visible(GTK_WIDGET(dropdown_obj), FALSE);
    }
    
    // Fetch detailed station data
    waqi_fetch_station_data(result.station_id, current_station_data);
    
    // Update legacy data structure for compatibility
    g_free(g_api_city_name);
    g_api_city_name = g_strdup(result.station_name.c_str());
    current_aqi_data.city = g_api_city_name;
    current_aqi_data.aqi = current_station_data.aqi;
    current_aqi_data.pm25 = current_station_data.pm25;
    current_aqi_data.pm10 = current_station_data.pm10;
    
    // Set status based on AQI
    if (current_aqi_data.aqi <= 50) current_aqi_data.status = "Good ðŸŸ¢";
    else if (current_aqi_data.aqi <= 100) current_aqi_data.status = "Satisfactory ðŸŸ¡";
    else if (current_aqi_data.aqi <= 150) current_aqi_data.status = "Moderate ðŸŸ ";
    else if (current_aqi_data.aqi <= 200) current_aqi_data.status = "Unhealthy ðŸŸ ";
    else if (current_aqi_data.aqi <= 300) current_aqi_data.status = "Very Unhealthy ðŸ”´";
    else current_aqi_data.status = "Hazardous â˜ ï¸";
    
    // Copy hourly history for chart
    current_aqi_data.history.clear();
    for (double val : current_station_data.pm25_history) {
        current_aqi_data.history.push_back((int)val);
    }
    // Pad with zeros if not enough history
    while (current_aqi_data.history.size() < 24) {
        current_aqi_data.history.insert(current_aqi_data.history.begin(), current_aqi_data.aqi);
    }
    
    // Update display
    update_aqi_display(builder);
}

// Populate search dropdown with results
static void populate_search_dropdown(GtkBuilder *builder) {
    GObject *dropdown_obj = gtk_builder_get_object(builder, "search_dropdown");
    GObject *listbox_obj = gtk_builder_get_object(builder, "search_results_list");
    
    if (!dropdown_obj || !listbox_obj) {
        g_print("Search dropdown UI elements not found!\n");
        return;
    }
    
    GtkListBox *listbox = GTK_LIST_BOX(listbox_obj);
    
    // Clear existing rows
    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(GTK_WIDGET(listbox))) != NULL) {
        gtk_list_box_remove(listbox, child);
    }
    
    // Add results
    for (const auto& result : search_results) {
        GtkWidget *row = gtk_list_box_row_new();
        GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
        gtk_widget_set_margin_start(box, 10);
        gtk_widget_set_margin_end(box, 10);
        gtk_widget_set_margin_top(box, 8);
        gtk_widget_set_margin_bottom(box, 8);
        
        // Station name and location
        GtkWidget *info_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
        gtk_widget_set_hexpand(info_box, TRUE);
        
        GtkWidget *name_label = gtk_label_new(result.station_name.c_str());
        gtk_label_set_xalign(GTK_LABEL(name_label), 0);
        gtk_widget_add_css_class(name_label, "heading");
        
        char subtitle[256];
        snprintf(subtitle, sizeof(subtitle), "%s â€¢ %s", result.country.c_str(), result.source.c_str());
        GtkWidget *subtitle_label = gtk_label_new(subtitle);
        gtk_label_set_xalign(GTK_LABEL(subtitle_label), 0);
        gtk_widget_add_css_class(subtitle_label, "dim-label");
        gtk_widget_add_css_class(subtitle_label, "caption");
        
        gtk_box_append(GTK_BOX(info_box), name_label);
        gtk_box_append(GTK_BOX(info_box), subtitle_label);
        
        // AQI badge
        GtkWidget *aqi_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
        gtk_widget_set_valign(aqi_box, GTK_ALIGN_CENTER);
        
        char aqi_str[16];
        if (result.has_aqi) {
            snprintf(aqi_str, sizeof(aqi_str), "%d", result.aqi);
        } else {
            snprintf(aqi_str, sizeof(aqi_str), "--");
        }
        GtkWidget *aqi_label = gtk_label_new(aqi_str);
        gtk_widget_add_css_class(aqi_label, "title-2");
        
        // Color based on AQI
        if (result.has_aqi) {
            if (result.aqi <= 50) gtk_widget_add_css_class(aqi_label, "aqi-good");
            else if (result.aqi <= 100) gtk_widget_add_css_class(aqi_label, "aqi-ok");
            else gtk_widget_add_css_class(aqi_label, "aqi-bad");
        }
        
        gtk_box_append(GTK_BOX(aqi_box), aqi_label);
        
        gtk_box_append(GTK_BOX(box), info_box);
        gtk_box_append(GTK_BOX(box), aqi_box);
        
        gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(row), box);
        gtk_list_box_append(listbox, row);
    }
    
    // Show/hide dropdown
    gtk_widget_set_visible(GTK_WIDGET(dropdown_obj), !search_results.empty());
}
#endif

// Update the AQI display with current data
static void update_aqi_display(GtkBuilder *builder) {
    GObject *result_box_obj = gtk_builder_get_object(builder, "aqi_result_box");
    if (!result_box_obj) return;
    
    GtkLabel *lbl_city = GTK_LABEL(gtk_builder_get_object(builder, "lbl_city_name"));
    GtkLabel *lbl_aqi = GTK_LABEL(gtk_builder_get_object(builder, "lbl_aqi_value"));
    GtkLabel *lbl_status = GTK_LABEL(gtk_builder_get_object(builder, "lbl_aqi_status"));
    GtkLabel *lbl_pm25 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_pm25"));
    GtkLabel *lbl_pm10 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_pm10"));
    
    char buffer[64];
    
    if (lbl_city) gtk_label_set_text(lbl_city, current_aqi_data.city);
    
    if (lbl_aqi) {
        snprintf(buffer, sizeof(buffer), "%d", current_aqi_data.aqi);
        gtk_label_set_text(lbl_aqi, buffer);
    }
    
    if (lbl_status) gtk_label_set_text(lbl_status, current_aqi_data.status);
    
    if (lbl_pm25) {
        snprintf(buffer, sizeof(buffer), "PM2.5: %.1f Âµg/mÂ³", current_aqi_data.pm25);
        gtk_label_set_text(lbl_pm25, buffer);
    }
    
    if (lbl_pm10) {
        snprintf(buffer, sizeof(buffer), "PM10: %.1f Âµg/mÂ³", current_aqi_data.pm10);
        gtk_label_set_text(lbl_pm10, buffer);
    }
    
    // Update pollutant details if available
    GtkLabel *lbl_o3 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_o3"));
    GtkLabel *lbl_no2 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_no2"));
    GtkLabel *lbl_co = GTK_LABEL(gtk_builder_get_object(builder, "lbl_co"));
    GtkLabel *lbl_so2 = GTK_LABEL(gtk_builder_get_object(builder, "lbl_so2"));
    
    if (lbl_o3 && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "Oâ‚ƒ: %.1f ppb", current_station_data.o3);
        gtk_label_set_text(lbl_o3, buffer);
    }
    
    if (lbl_no2 && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "NOâ‚‚: %.1f ppb", current_station_data.no2);
        gtk_label_set_text(lbl_no2, buffer);
    }
    
    if (lbl_co && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "CO: %.1f ppm", current_station_data.co / 1000.0);
        gtk_label_set_text(lbl_co, buffer);
    }
    
    if (lbl_so2 && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "SOâ‚‚: %.2f ppb", current_station_data.so2);
        gtk_label_set_text(lbl_so2, buffer);
    }
    
    // Update weather info
    GtkLabel *lbl_temp = GTK_LABEL(gtk_builder_get_object(builder, "lbl_temperature"));
    GtkLabel *lbl_humidity = GTK_LABEL(gtk_builder_get_object(builder, "lbl_humidity"));
    GtkLabel *lbl_wind = GTK_LABEL(gtk_builder_get_object(builder, "lbl_wind"));
    
    if (lbl_temp && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "ðŸŒ¡ï¸ %.1fÂ°C", current_station_data.temperature);
        gtk_label_set_text(lbl_temp, buffer);
    }
    
    if (lbl_humidity && current_station_data.has_data) {
        snprintf(buffer, sizeof(buffer), "ðŸ’§ %.0f%%", current_station_data.humidity);
        gtk_label_set_text(lbl_humidity, buffer);
    }
    
    if (lbl_wind && current_station_data.has_data) {
        const char* wind_dir = "";
        int wd = current_station_data.wind_direction;
        if (wd >= 337 || wd < 22) wind_dir = "N";
        else if (wd < 67) wind_dir = "NE";
        else if (wd < 112) wind_dir = "E";
        else if (wd < 157) wind_dir = "SE";
        else if (wd < 202) wind_dir = "S";
        else if (wd < 247) wind_dir = "SW";
        else if (wd < 292) wind_dir = "W";
        else wind_dir = "NW";
        snprintf(buffer, sizeof(buffer), "ðŸ’¨ %.1f m/s %s", current_station_data.wind_speed, wind_dir);
        gtk_label_set_text(lbl_wind, buffer);
    }

    // Update Health Advice
    GtkLabel *lbl_advice = GTK_LABEL(gtk_builder_get_object(builder, "lbl_health_advice"));
    if (lbl_advice) {
        const char* advice = "";
        if (current_aqi_data.aqi <= 50) advice = "Air quality is good. Enjoy outdoor activities!";
        else if (current_aqi_data.aqi <= 100) advice = "Air quality is acceptable. Sensitive groups should limit prolonged outdoor exertion.";
        else if (current_aqi_data.aqi <= 150) advice = "Unhealthy for sensitive groups. Reduce prolonged outdoor exertion.";
        else if (current_aqi_data.aqi <= 200) advice = "Unhealthy. Everyone may experience health effects.";
        else if (current_aqi_data.aqi <= 300) advice = "Very unhealthy. Avoid outdoor activities.";
        else advice = "Hazardous! Avoid all outdoor activities.";
        gtk_label_set_text(lbl_advice, advice);
    }

    // Update Status Style
    if (lbl_status) {
        GtkWidget *status_widget = GTK_WIDGET(lbl_status);
        gtk_widget_remove_css_class(status_widget, "aqi-good");
        gtk_widget_remove_css_class(status_widget, "aqi-ok");
        gtk_widget_remove_css_class(status_widget, "aqi-bad");

        if (current_aqi_data.aqi <= 50) gtk_widget_add_css_class(status_widget, "aqi-good");
        else if (current_aqi_data.aqi <= 100) gtk_widget_add_css_class(status_widget, "aqi-ok");
        else gtk_widget_add_css_class(status_widget, "aqi-bad");
    }
    
    // Show results
    gtk_widget_set_visible(GTK_WIDGET(result_box_obj), TRUE);
    
    // Redraw chart
    GObject *chart_area_obj = gtk_builder_get_object(builder, "chart_area_current");
    if (chart_area_obj) {
        gtk_widget_queue_draw(GTK_WIDGET(chart_area_obj));
    }
    
    // Show pollutant detail box if we have data
    GObject *pollutant_box = gtk_builder_get_object(builder, "pollutant_detail_box");
    if (pollutant_box && current_station_data.has_data) {
        gtk_widget_set_visible(GTK_WIDGET(pollutant_box), TRUE);
    }
    
    // Show weather box if we have data
    GObject *weather_box = gtk_builder_get_object(builder, "weather_box");
    if (weather_box && current_station_data.has_data) {
        gtk_widget_set_visible(GTK_WIDGET(weather_box), TRUE);
    }
}

static void on_fetch_aqi_clicked(GtkButton *button, gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    
    GObject *entry_obj = gtk_builder_get_object(builder, "city_entry");
    if (!entry_obj) return;
    
    const char *city = gtk_editable_get_text(GTK_EDITABLE(entry_obj));
    if (!city || !*city) {
        city = "Delhi"; // Default city
    }
    
#ifndef __ANDROID__
    // Search for the city and auto-select first result
    waqi_search_cities(city, search_results);
    
    if (!search_results.empty()) {
        const WAQISearchResult &result = search_results[0];
        
        // Fetch detailed station data
        waqi_fetch_station_data(result.station_id, current_station_data);
        
        // Update legacy data structure
        g_free(g_api_city_name);
        g_api_city_name = g_strdup(result.station_name.c_str());
        current_aqi_data.city = g_api_city_name;
        current_aqi_data.aqi = current_station_data.has_data ? current_station_data.aqi : result.aqi;
        current_aqi_data.pm25 = current_station_data.pm25;
        current_aqi_data.pm10 = current_station_data.pm10;
        
        // Set status
        if (current_aqi_data.aqi <= 50) current_aqi_data.status = "Good ðŸŸ¢";
        else if (current_aqi_data.aqi <= 100) current_aqi_data.status = "Satisfactory ðŸŸ¡";
        else if (current_aqi_data.aqi <= 150) current_aqi_data.status = "Moderate ðŸŸ ";
        else if (current_aqi_data.aqi <= 200) current_aqi_data.status = "Unhealthy ðŸŸ ";
        else if (current_aqi_data.aqi <= 300) current_aqi_data.status = "Very Unhealthy ðŸ”´";
        else current_aqi_data.status = "Hazardous â˜ ï¸";
        
        // Copy history
        current_aqi_data.history.clear();
        for (double val : current_station_data.pm25_history) {
            current_aqi_data.history.push_back((int)val);
        }
        while (current_aqi_data.history.size() < 24) {
            current_aqi_data.history.insert(current_aqi_data.history.begin(), current_aqi_data.aqi);
        }
    } else {
        // Fallback to mock data
        current_aqi_data = get_mock_data(city);
    }
#else
    current_aqi_data = get_mock_data(city);
#endif
    
    // Hide search dropdown
    GObject *dropdown_obj = gtk_builder_get_object(builder, "search_dropdown");
    if (dropdown_obj) {
        gtk_widget_set_visible(GTK_WIDGET(dropdown_obj), FALSE);
    }
    
    update_aqi_display(builder);
}

static void on_play_clicked(GtkButton *button, gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    GObject *entry_obj = gtk_builder_get_object(builder, "url_entry");
    GObject *video_obj = gtk_builder_get_object(builder, "video_player");

    if (!entry_obj || !video_obj) return;

    GtkEntry *entry = GTK_ENTRY(entry_obj);
    GtkVideo *video = GTK_VIDEO(video_obj);
    
    const char *url = gtk_editable_get_text(GTK_EDITABLE(entry));
    
    if (url && *url) {
        GFile *file = g_file_new_for_uri(url);
        gtk_video_set_file(video, file);
        g_object_unref(file);
    }
}

static void on_sidebar_toggle_clicked(GtkToggleButton *button, gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    GObject *split_obj = gtk_builder_get_object(builder, "split_view");
    
    if (!split_obj) return;
    
    gboolean active = gtk_toggle_button_get_active(button);
    adw_navigation_split_view_set_show_content(ADW_NAVIGATION_SPLIT_VIEW(split_obj), !active);
}

static void on_nav_row_selected(GtkListBox *box, GtkListBoxRow *row, gpointer user_data) {
    if (!row) return;
    GtkBuilder *builder = GTK_BUILDER(user_data);
    
    GObject *stack_obj = gtk_builder_get_object(builder, "main_stack");
    GObject *split_obj = gtk_builder_get_object(builder, "split_view");
    GObject *title_obj = gtk_builder_get_object(builder, "content_title");
    
    if (!stack_obj) return;
    
    GtkStack *stack = GTK_STACK(stack_obj);
    int idx = gtk_list_box_row_get_index(row);
    
    const char *page_names[] = {"dashboard", "live_charts", "video"};
    const char *titles[] = {"Dashboard", "Live Charts", "Media Player"};
    const char *subtitles[] = {"Air Quality", "System Monitoring", "Video"};
    
    if (idx >= 0 && idx < 3) {
        gtk_stack_set_visible_child_name(stack, page_names[idx]);
        
        // Update header title
        if (title_obj) {
            adw_window_title_set_title(ADW_WINDOW_TITLE(title_obj), titles[idx]);
            adw_window_title_set_subtitle(ADW_WINDOW_TITLE(title_obj), subtitles[idx]);
        }
        
        // Collapse sidebar on mobile after selection
        if (split_obj && adw_navigation_split_view_get_collapsed(ADW_NAVIGATION_SPLIT_VIEW(split_obj))) {
            g_object_set(split_obj, "show-sidebar", FALSE, NULL);
        }
    }
}

static gboolean on_live_tick(gpointer user_data) {
    GtkBuilder *builder = GTK_BUILDER(user_data);
    live_tick++;
    
    // Update CPU
    int cpu = (int)GetCPULoad();
    if (history_cpu.size() >= 24) history_cpu.erase(history_cpu.begin());
    history_cpu.push_back(cpu);

    // Update Mem
    int mem = (int)GetMemoryUsage();
    if (history_mem.size() >= 24) history_mem.erase(history_mem.begin());
    history_mem.push_back(mem);

    // Update Net
    int net = (int)GetNetworkUsage(); 
    if (history_net.size() >= 24) history_net.erase(history_net.begin());
    history_net.push_back(net);

    const char *ids[] = {"chart_live_cpu", "chart_live_mem", "chart_live_net", NULL};
    for (const char **id = ids; *id; id++) {
        GObject *obj = gtk_builder_get_object(builder, *id);
        if (obj) gtk_widget_queue_draw(GTK_WIDGET(obj));
    }
    return TRUE; // Continue calling
}

static void load_custom_css() {
    GtkCssProvider *provider = gtk_css_provider_new();
    const char *css_data = 
        "window { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }"
        ".sidebar { background-color: #f8f9fa; border-right: 1px solid #dee2e6; }"
        ".sidebar list { background-color: transparent; }"
        ".sidebar row { padding: 10px 16px; color: #333; font-weight: 500; border-radius: 4px; margin: 2px 8px; }"
        ".sidebar row:selected { color: #0d6efd; background-color: rgba(13, 110, 253, 0.1); }"
        ".navigation-sidebar image { color: #495057; -gtk-icon-style: symbolic; }"
        ".navigation-sidebar row:selected image { color: #0d6efd; }"
        ".dashboard-title { font-size: 28px; font-weight: 600; color: #212529; }"
        ".section-title { font-size: 20px; font-weight: 600; color: #212529; margin-top: 24px; margin-bottom: 16px; border-bottom: 1px solid #dee2e6; padding-bottom: 8px; }"
        ".card { background-color: #fff; border: 1px solid rgba(0,0,0,.125); border-radius: 4px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.02); }"
        ".stat-value { font-size: 28px; font-weight: 700; color: #212529; }"
        ".stat-label { font-size: 13px; color: #6c757d; font-weight: 600; text-transform: uppercase; }"
        ".btn-primary { background-color: #0d6efd; color: white; border-radius: 4px; font-weight: 600; padding: 6px 12px; }"
        ".btn-outline { background-color: white; color: #6c757d; border: 1px solid #6c757d; border-radius: 4px; font-weight: 600; padding: 6px 12px; }"
        ".aqi-good { color: #198754; }"
        ".aqi-ok { color: #fd7e14; }"
        ".aqi-bad { color: #dc3545; }"
        ".video-card { padding: 0; overflow: hidden; border-radius: 12px; }"
        ".video-card video { border-radius: 12px; background: #000; min-height: 200px; }";
    gtk_css_provider_load_from_string(provider, css_data);
    
    GdkDisplay *display = gdk_display_get_default();
    if (display) {
        gtk_style_context_add_provider_for_display(display,
            GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    }
    g_object_unref(provider);
}

static void on_activate(GtkApplication *app, gpointer user_data) {
    // Ensure libadwaita types are registered (MUST be before GtkBuilder parses UI)
    adw_init();
    
    // Explicitly ensure libadwaita widget types are registered
    // This is needed on Android because the types may not be auto-registered
    g_type_ensure(ADW_TYPE_APPLICATION_WINDOW);
    g_type_ensure(ADW_TYPE_HEADER_BAR);
    g_type_ensure(ADW_TYPE_CLAMP);
    g_type_ensure(ADW_TYPE_NAVIGATION_SPLIT_VIEW);
    g_type_ensure(ADW_TYPE_NAVIGATION_PAGE);
    g_type_ensure(ADW_TYPE_TOOLBAR_VIEW);
    g_type_ensure(ADW_TYPE_WINDOW_TITLE);
    
    // Register GResource for Android only
#ifdef __ANDROID__
    GResource *resource = resources_get_resource();
    g_resources_register(resource);
#endif
    
    load_custom_css();
    GtkBuilder *builder = gtk_builder_new();
    GError *error = NULL;
    
#ifdef __ANDROID__
    // Android: Load from GResource
    if (!gtk_builder_add_from_resource(builder, "/com/example/mygtk4app/layout.ui", &error)) {
        g_printerr("Error loading layout.ui from resource: %s\n", error->message);
        g_clear_error(&error);
        return;
    }
#else
    // Desktop: Load directly from file
    if (!gtk_builder_add_from_file(builder, "layout.ui", &error)) {
        g_printerr("Error loading layout.ui: %s\n", error->message);
        g_clear_error(&error);
        return;
    }
#endif
    
    GObject *window_obj = gtk_builder_get_object(builder, "window");
    if (!window_obj) {
        g_printerr("Error: No 'window' object in layout.ui\n");
        return;
    }
    
    GtkWindow *window = GTK_WINDOW(window_obj);
    gtk_window_set_application(window, app);
    
    // Connect Signals
    GObject *btn_fetch = gtk_builder_get_object(builder, "btn_fetch_aqi");
    if (btn_fetch) g_signal_connect(btn_fetch, "clicked", G_CALLBACK(on_fetch_aqi_clicked), builder);
    
#ifndef __ANDROID__
    // Connect city entry for live search
    GObject *city_entry = gtk_builder_get_object(builder, "city_entry");
    if (city_entry) {
        g_signal_connect(city_entry, "changed", G_CALLBACK(on_city_entry_changed), builder);
    }
    
    // Connect search results list for selection
    GObject *search_list = gtk_builder_get_object(builder, "search_results_list");
    if (search_list) {
        g_signal_connect(search_list, "row-selected", G_CALLBACK(on_search_result_selected), builder);
    }
#endif
    
    GObject *btn_play = gtk_builder_get_object(builder, "play_button");
    if (btn_play) g_signal_connect(btn_play, "clicked", G_CALLBACK(on_play_clicked), builder);
    
    // Connect sidebar toggle button
    GObject *sidebar_toggle = gtk_builder_get_object(builder, "sidebar_toggle");
    if (sidebar_toggle) {
        g_signal_connect(sidebar_toggle, "toggled", G_CALLBACK(on_sidebar_toggle_clicked), builder);
    }
    // Connect Navigation List
    GObject *nav_list = gtk_builder_get_object(builder, "nav_list");
    if (nav_list) {
        g_signal_connect(nav_list, "row-selected", G_CALLBACK(on_nav_row_selected), builder);
        // Select the first row by default
        GtkListBoxRow *first_row = gtk_list_box_get_row_at_index(GTK_LIST_BOX(nav_list), 0);
        if (first_row) gtk_list_box_select_row(GTK_LIST_BOX(nav_list), first_row);
    }
    
    // Connect Chart Drawing
    GObject *chart_current = gtk_builder_get_object(builder, "chart_area_current");
    if (chart_current) {
        gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(chart_current), on_draw_chart, NULL, NULL);
        
        // Add Event Controller
        GtkEventController *motion = gtk_event_controller_motion_new();
        g_signal_connect(motion, "motion", G_CALLBACK(on_chart_motion), chart_current);
        g_signal_connect(motion, "leave", G_CALLBACK(on_chart_leave), chart_current);
        gtk_widget_add_controller(GTK_WIDGET(chart_current), motion);
    }

    GObject *chart_delhi = gtk_builder_get_object(builder, "chart_area_delhi");
    if (chart_delhi) {
        g_object_set_data(G_OBJECT(chart_delhi), "city_name", (gpointer)"New Delhi");
        gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(chart_delhi), on_draw_chart, NULL, NULL);
    }

    GObject *chart_mumbai = gtk_builder_get_object(builder, "chart_area_mumbai");
    if (chart_mumbai) {
        g_object_set_data(G_OBJECT(chart_mumbai), "city_name", (gpointer)"Mumbai");
        gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(chart_mumbai), on_draw_chart, NULL, NULL);
    }

    // Live Charts Setup
    struct LiveChartConfig { const char* id; const char* type; };
    LiveChartConfig live_charts[] = {
        {"chart_live_cpu", "CPU Load"},
        {"chart_live_mem", "Memory Usage"},
        {"chart_live_net", "Network Traffic"}
    };

    for (const auto& cfg : live_charts) {
        GObject *obj = gtk_builder_get_object(builder, cfg.id);
        if (obj) {
            GtkWidget *w = GTK_WIDGET(obj);
            g_object_set_data(G_OBJECT(w), "is_live", (gpointer)1);
            g_object_set_data(G_OBJECT(w), "live_type", (gpointer)cfg.type);
            gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(w), on_draw_chart, NULL, NULL);
            
            // Add interactivity
            GtkEventController *motion = gtk_event_controller_motion_new();
            g_signal_connect(motion, "motion", G_CALLBACK(on_chart_motion), w);
            g_signal_connect(motion, "leave", G_CALLBACK(on_chart_leave), w);
            gtk_widget_add_controller(w, motion);
        }
    }
    
    // Start Live Update Timer
    g_timeout_add(1000, on_live_tick, builder);
    
    gtk_window_present(window);
    g_object_set_data_full(G_OBJECT(window), "builder", builder, g_object_unref);
}

int main(int argc, char *argv[]) {
#ifndef __ANDROID__
    // Force GStreamer backend for GTK Media (not available on Android)
    g_setenv("GTK_MEDIA_DRIVER", "gstreamer", TRUE);
    
    // Initialize GStreamer
    gst_init(&argc, &argv);
#endif
    
    // Initialize LibAdwaita (this initializes GTK as well)
    // Note: AdwApplication handles this automatically, but since we use GtkApplication
    // we should call adw_init() if we want to use Adwaita widgets without AdwApplication.
    // However, using AdwApplication is better.
    
    AdwApplication *app = adw_application_new("com.example.aqi", G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, "activate", G_CALLBACK(on_activate), NULL);
    
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    
    return status;
}